==============================================================================
tlconfig.lua
==============================================================================
0 return {
      source_dir = "src",
      include_dir = { "src/typedefs", "src/", "packages/" },
0     include = {
          "**/**.tl",
      },
      --[[   scripts = {
          build = {
              post = {
                  "scripts/copy_lua_packages.lua",
              },
          },
      }, ]]
      build_dir = "build",
      global_env_def = "ao",
     -- module_name = "vrf",
      gen_target = "5.3",
  }

==============================================================================
process.lua
==============================================================================
  do
0 local _ENV = _ENV
0 package.preload[ "database" ] = function( ... ) local arg = _G.arg;
0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local pcall = _tl_compat and _tl_compat.pcall or pcall

0 require("globals")

0 local sqlite3 = require("lsqlite3")

0 DB = DB or sqlite3.open_memory()
0 Configured = Configured or false

0 local database = {}

  local function initializeDatabaseConnection()
0    if not DB then
0       local ok, err = pcall(function()
0          return sqlite3.open_memory()
        end)
0       if not ok then
0          print("Failed to initialize database connection: " .. tostring(err))
0          return false
        end
0       DB = err
     end
0    return true
  end

  local function executeSQL(sql)
0    local ok, err = pcall(function()
0       DB:exec(sql)
     end)
0    if not ok then
0       return false, "Failed to execute SQL: " .. tostring(err)
     end
0    return true, ""
  end

0 function database.initializeDatabase()
0    print("Initializing database")
0    if not initializeDatabaseConnection() then
0       return false
     end

0    if not Configured then
0       print("Setting up database schema")
0       local tables = {

0          [[
          CREATE TABLE IF NOT EXISTS Providers (
            provider_id TEXT PRIMARY KEY,
            stake INTEGER,
            active INTEGER,
            active_challenge_requests TEXT,
            active_output_requests TEXT,
            random_balance INTEGER,
            created_at INTEGER
          );
        ]],

0          [[
          CREATE TABLE IF NOT EXISTS Verifiers (
            process_id TEXT PRIMARY KEY,
            status TEXT NOT NULL,
            current_segment TEXT
          )
        ]],

0          [[
          CREATE TABLE IF NOT EXISTS VerifierSegments (
            segment_id TEXT PRIMARY KEY,
            proof_id TEXT NOT NULL,
            verifier_id TEXT,
            segment_data TEXT NOT NULL,
            status TEXT NOT NULL,
            timestamp INTEGER NOT NULL,
            result TEXT,
            FOREIGN KEY(verifier_id) REFERENCES Verifiers(process_id)
          )
        ]],
0          [[
          CREATE TABLE IF NOT EXISTS RandomRequests (
            request_id TEXT PRIMARY KEY,
            requester TEXT,
            callback_id TEXT,
            providers TEXT,
            requested_inputs INTEGER,
            status TEXT,
            entropy TEXT,
            created_at INTEGER
          );
        ]],
0          [[
          CREATE TABLE IF NOT EXISTS ProviderVDFResults (
            request_id TEXT,
            provider_id TEXT,
            input_value TEXT,
            modulus_value TEXT,
            output_value TEXT,
            proof TEXT,
            created_at INTEGER,
            PRIMARY KEY (request_id, provider_id),
            FOREIGN KEY (request_id) REFERENCES RandomRequests(request_id)
          );
        ]],
        }

0       for _, sql in ipairs(tables) do
0          local ok, err = executeSQL(sql)
0          if not ok then
0             print("Database initialization failed: " .. err)
0             return false
           end
        end

0       Configured = true
     end

0    print("Database initialization complete")
0    return true
  end

0 return database
  end
  end

  do
0 local _ENV = _ENV
0 package.preload[ "dbUtils" ] = function( ... ) local arg = _G.arg;
0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local pcall = _tl_compat and _tl_compat.pcall or pcall; local table = _tl_compat and _tl_compat.table or table; require("globals")

0 local sqlite3 = require('lsqlite3')
0 local dbUtils = {}

0 function dbUtils.queryMany(stmt)
0    local rows = {}

0    if stmt then
0       for row in stmt:nrows() do
0          table.insert(rows, row)
        end
0       stmt:finalize()
     else
0       error("Err: " .. DB:errmsg())
     end
0    return rows
  end

0 function dbUtils.queryOne(stmt)
0    return dbUtils.queryMany(stmt)[1]
  end

0 function dbUtils.rawQuery(query)
0    local stmt = DB:prepare(query)
0    if not stmt then
0       error("Err: " .. DB:errmsg())
     end
0    return dbUtils.queryMany(stmt)
  end

0 function dbUtils.execute(stmt, statementHint)

0    statementHint = statementHint or "Unknown operation"


0    if type(stmt) ~= "userdata" then
0       return false, "Invalid statement object"
     end


0    print("dbUtils.execute: Executing SQL statement")

0    if stmt then
0       local step_ok, step_err = pcall(function() stmt:step() end)
0       if not step_ok then
0          print("dbUtils.execute: SQL execution failed: " .. tostring(step_err))
0          return false, "dbUtils.execute: Failed to execute SQL statement StatementHint being: " .. tostring(step_err)
        end

0       local finalize_result = stmt:finalize()
0       if finalize_result ~= sqlite3.OK then
0          print("dbUtils.execute: SQL finalization failed: " .. DB:errmsg())
0          return false, "dbUtils.execute: Failed to finalize SQL statement StatementHint being: " .. DB:errmsg()
        end

0       print("dbUtils.execute: SQL execution successful")
0       return true, ""
     else
0       print("dbUtils.execute: Statement preparation failed: " .. DB:errmsg())
0       return false, "dbUtils.execute: Failed to prepare SQL statement StatementHint being:(" .. statementHint .. "): " .. DB:errmsg()
     end
  end

0 return dbUtils
  end
  end

  do
0 local _ENV = _ENV
0 package.preload[ "globals" ] = function( ... ) local arg = _G.arg;
0 require("lsqlite3")





0 Admin = "KLzn6IzhmML7M-XXFNSI29GVNd3xSHtH26zuKa1TWn8"



0 RequiredStake = 10
0 Cost = 100

0 TokenTest = "OeX1V1xSabUzUtNykWgu9GEaXqacBZawtK12_q5gXaA"
0 WrappedAR = "xU9zFkq3X2ZQ6olwNVvr1vUWIjc3kXTWr7xKQD6dh10"
0 TokenInUse = TokenTest

0 SuccessMessage = "200: Success"

0 Status = {
     "COLLECTING CHALLENGES",
     "COLLECTING OUTPUTS",
     "VERIFYING OUTPUTS",
     "CRACKING",
     "FINALIZED",
     "FAILED",
  }

0 VerifierProcesses = {
     "9xtciDYCCN76fXIq1cKosh3XNzG_Qj1D3Z5XK1g5nOE",
     "RG6r_xD_NZtbw7t2QcfrUXjrlZe3w3a9vK_Z4kTrZyc",
     "aDKAxaGZSMh120sVO-XMHc2oNxpl4Zst_KaC_YB3AK0",
     "bHNe_KSStb-pmhttS6x9B2QTZ8s_duspz-r3Fz89HmI",
     "hE4pw01XluNHiUfZONVCPEQJvy7A83FzR5GJgylJ2jE",
     "aIiqaop1mZ9XuIPLd_1xVDjkQ-_wEG0L3xCB1pwf6Zg",
     "1musHHlIsIqWL-v8zuLQCclWNOH0xEtM5Bop9npHIZ0",
     "E-hoJqDj2GB6J-oveM4B5J5c6WLFQ9f9P9MeVB7ZfRs",
     "bQbqmx4ju8QHIUsTTWRXbA8VD_LxZqhxHm79dE0xqB8",
     "1Rk_Nf0ohtQ8CcD31OYDYJv4pstJFJWhU5TOMdBgWNU",
     "Ca_j7Jcx9GtCZnGnhvSHKZQZiMdOOSyYlC5g74sofAM",
     "cjTEdlZPE2By_mVk6TYRotUIrGN5jZUom6mLsFFK7ZI",
     "HdwaaNv84kWolAAxxFcq-fj6GxchSojnSamYBfAdOlw",
     "m9YnpeUM7d0FMS647VFZKqwcq6yN6NDU_7388ZDIWgk",
     "5JLl8vaqbNJK-3Z9snnOx7cDciGR43nCKcm2X1g8LQs",
     "QrDVen99sF88EvE_vffdpHzMWRP5weVzH84gXfKct3Y",
     "sREsSXZC8UdLfBiic5Nsbl16gsdooRssbdZqtHR47xk",
     "LMli3AiUXlCZcr8lSacqqrqTiTQpuMQS1TFuFSYyYCc",
     "eme9ov7v6uvLOQ9xs7TPVw31liudHbjpmoSsJrb9yKM",
     "emiZ11GY1FLPItxbgDBtuDuZFwosSKydxdX2Y3X3syU",
     "3-TUgiU4CYXybgL7X2TCGAdGkGlFQgmJh63w9ah54p8",
     "6zdG4WZnHFq0iFrqt8if0VJjLD0uMTpwI3PKE2ebMuE",
     "f8DRxguG-ebm8qkeW87TfqQPfpjDx1zFawFLqdyVqEE",
     "-3FR3L_y41ChqUg9f3LzOOjCeEYqxZnxOPBSVJvhc4g",
     "7MyjbWK2ui4YCZvI4pAei632cTYZpkPyRsYSMpqVSjk",
     "o3F_-U5FD69JHSxZJcLU8CZnM6A0lJVaJEjb3tdpyHw",
     "ocTw1Q0119A6b25W9xPNpLP2whkeTkn2AvM_1vr6dwg",
     "5uckHZGTWwxJU7MfuBTrPwe6awdqpKxV0O-L6_kmuM0",
     "KYonYg0dcgjIZHur58aq1l_Xd6FV2995C9M7IKx9ToY",
     "pCO8DCinMo2iBEYSxnpzMsQsVICnM9I3iFpHvJhiquU",
     "Zg7NsaOfedtTYZwu6HyCjpfiAMDJU2L-5zube7Pnnoc",
     "RwPOZCTE2N9GkztErOqgVWcPOQCvbkMtv6-OxIqtb3Y",
     "tNpWqM0aGL6-6CSpHb2Wrw4jCH3irwrsrpubpK9c_jg",
     "liUYPzYtFcSmtZw-kixB5fYWAAIwqoeiYcy3LqI0r5g",
     "mFSAyqgeAqph4uPNAbONTvxrYR-5-BFGpvSzbl89rEM",
     "VZjKTKen3yCRwS3fhlzb8gy040-o6cB4nc4WuzMhO_0",
     "jb5PbvwDOPvv2VQJhDBaRapsS7Hg0_nbgklRqy4NCRo",
     "MdOSjRFFPXVPZ1QuFc24aS2iH6LPBMMVtz0Hfou_YTY",
     "7lUE6vTtYzz9DX7Vel0PiVr9Gt7WXsraBfGbzsb-J0o",
     "Ad5zPlVDcyO8A_gZuCZafRG-hloEG4GEiuM3i5q_7ew",
     "0UHuoupRYAWi2ES727gWXxiB6NywyY5uSXv5pPQmWF4",
     "5zkXkGJxhXiBeHj8rFV7pMexegQYYurqR7iXuK_OeTA",
     "6NcC5lNFwyrZTyXEZ_BUpED8tlz-ml3UDVEnpsqn7NQ",
     "-B2h9yKLQ6Gmz53K2Y0B7I-maT6n3LyuX86nxp0caak",
     "ieFMM-zqmQpGrVmnFgsyqM865GS1-A5R37krMZ2PahI",
     "jrZ5KxMErZL_2aet5OVdYQZH1iyFn4MYoZ3qDeRADb0",
     "vjoC1Vu46Kz_MXcEOQJM6tuSgkpdnJZoVCjJv8_15w8",
     "YhQ9OPQQnjQXumInOLad4jp73Rv6OEEcE6FIjLnIs_g",
     "8n5FmNyOXz_y5WtROyaNdlKYjCmPN5Xz0nYlYu4HRKs",
     "GlPXlvwNgnu1wmYgDdSxX9pRCAlVUU-FeHznW5pFAX4",
     "6fzr6mfZMyY7J0gn5k2Lx-YzZpuJRDVVIIQ30eqvxIw",
     "XMjyw1B5ovTM1vuzWFiivD9C7HvTv-fzanl2ygpanRU",
     "1BaATgamA1HmAhAIaN6QzoXpjxNhNmSv41ZzQzVwlE4",
     "oIhKTSdl953AAly5HqnVnjlqdIkAMj5FxaG5QCMZ5OY",
     "8psb-hqCnQQpHPUVo7FASXA05f6GModOEryfBwR7jpc",
     "BfC87x5k19oU0dpCyoRQWrsjXhtM-1xzqLebQdki1JA",
     "HgY9erwSLwyUpXm3N6DhhSxbIzJ3XjFTqNJDVg9WJTY",
     "Bs5eEY7k5tDxO57l1SxgeWUx502-oLzegJIq5-eMz0Q",
     "3bu5EGUaF1RyR8_B28r_m2R4kpCytXWNikDQ4qDrPQM",
     "PjSK3CiGVn6iAGO5WCLIiLsrUabTXtXl6eyDFtUDrPU",
     "A5x89r00o1K_EEcYJhLTwfSmNHcU04KpslFE2GZUNEM",
     "0McQMqhI_G8F2S5R1oh5g4S4sGWxkMcD2MaVa5ELUAM",
     "iMMa2HbP-FQwiTdoK7W4GVHKD543KB221P6HAkfIKP0",
     "8gJT4MviAqdthfUjjXWrL9WDIO1zhwKNdF1HHjlsWGw",
     "JRt6hoW9blsADCdJbY8ThqJirDrj3SLSqM4CrUd1bh0",
     "mVbZzo75noxadsLdqUq64GE2fMBDvS6MB29gDnK2V4c",
     "0auksaSe4yV5Snv3MzLcJegJh7GyxXMYXP6ncjyfOfk",
     "am7uRfcD71c9ynlSXHjQZonPj8mRyp2Hz_PmzHLQ60Y",
     "NQcOoJM8m5-nxTXcJnuAeZW3PP1pT3vfi0FU9Vh5yTY",
     "k5PGnF9aoVZd26mo4e2W_6uZKl_ETATFZ4dzu9-NA-w",
     "c_0ye66-HsNRp0Dqmw4wga_XcYkK7YFIiiaPGeMY1uQ",
     "pOM79mJ6_6_2m5oLSMqFTKMC-eWUub8NU1MBgyluHA8",
     "ZC2FgZe2QPgKD4-C5120ISgull4zaJXSxz0wZqITLss",
     "gwCxgBfhdGu3gxYuuUl3pk_KVQF0V3ACpWPH2W0piLE",
     "4eVREWXvmKAMJ4RMiq9nhKbO93Sodme9a5MnMa_ObYs",
     "WyXBXMLGYpNcRhvrHrshjhFoV4PvTi1Gjj-CJh7zqto",
     "347w4pv7GnEI_0ZiqmXtl3lC3bXIBh-rhKwl1zuB0BM",
     "ccZiKD1yn8_bBHo69GVp8KOygbGh_tEn8lJHs6PGOzc",
     "0v9AAs9fhDkJyjYG7M0rViBOLlJ_DmJA-81MV7LSNnA",
     "EPocFs8XlXJhSNtcRTAjfkAUeWLG41tkSWFwK35iNfk",
     "EdvD-KQjeWtMzjW_atVR22jWJBCyNKv5ajolm0PYBj0",
     "n-CRbJNzKejlnqLNnse4aDzx4lKe0nAwcx1FrvY4pnI",
     "j2d4SznuLaSegIpN3_u85v9adVAL8NM2IrZFjjTty5k",
     "NUs5IVOr5KjydjjqLkkA6pstAgmtcPxJWknGRfA9JeY",
     "Dy45_39YaFd965jVbo57JiG-zbX9O6MpPqH5h6J9-ss",
     "1aF5qXxLA9bXihNZOmi_Gr9axwYdX8ZxIqjYTZpYITQ",
     "BEpOW5X2CPTlaKeE4NdKxzcN9Xjisic5Rmo5YebwZb8",
     "bLEW4XGsGo5IBXvXE2G5-Ai9GjymrHl5gWKwoUXyD1c",
     "4iYpSip0GqQ8Xekz-OdUf4n3AqFRwyyGEySeIcOapiw",
     "xh0satyfKYauDygZXCGwYlshCcEiec2vgYAAZvlC2aA",
     "FQ3XFhjwm7DT156S2MEi_wakF9s1n6LYPv2J8f-Ay1E",
     "HcCyWiR5eB-qAZclP_-aB5dsujK-TUHWU___Bkx5uAk",
     "zq_JQLzR2fVaw_PWxmA2WD0hJX7QFJgz3TF1XTJ5JQk",
     "kN6avGRarPdvCWMUDi5R7XFEnpRXdOy2FCv1QWkZtRc",
     "C1CElYtiNFeXaJ3YoGMNPTUv_NxJaF197F31qSHrmDI",
     "YLzRgccaT2XrRpeSrVkSJ--DGDCaW7ngkOTtVVQcG5o",
     "cjusi39QOnOdXinkJi3vcvWb8EDvNhs2qRL-M0Do9OA",
     "G6bjwtb3GIksAyF4N2zIJLcpDcXpsl3Icx2McOgoxEE",
     "H5wGgdYLz2RNtH4oAOe8ssBpABI5a5Dz2phktms6Hyk",
  }

0 return {}
  end
  end

  do
0 local _ENV = _ENV
0 package.preload[ "providerManager" ] = function( ... ) local arg = _G.arg;
0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local os = _tl_compat and _tl_compat.os or os; local pcall = _tl_compat and _tl_compat.pcall or pcall; local table = _tl_compat and _tl_compat.table or table; require("globals")

0 local dbUtils = require("dbUtils")
0 local json = require("json")


0 Provider = {}









0 ProviderList = {}



0 RequestList = {}



0 local providerManager = {}

0 function providerManager.createProvider(userId)
0    print("entered providerManager.createProvider")

0    local timestamp = os.time()

0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    print("Preparing SQL statement for provider creation")
0    local stmt = DB:prepare([[
      INSERT OR IGNORE INTO Providers (provider_id, created_at)
      VALUES (:provider_id, :created_at);
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    print("Binding parameters for provider creation")
0    local bind_ok, bind_err = pcall(function()
0       stmt:bind_names({ provider_id = userId, created_at = timestamp })
     end)

0    if not bind_ok then
0       print("Failed to bind parameters: " .. tostring(bind_err))
0       stmt:finalize()
0       return false, "Failed to bind parameters: " .. tostring(bind_err)
     end

0    print("Executing provider creation statement")
0    local execute_ok, execute_err = dbUtils.execute(stmt, "Create provider")

0    if not execute_ok then
0       print("Provider creation failed: " .. execute_err)
     else
0       print("Provider created successfully")
     end

0    return execute_ok, execute_err
  end

0 function providerManager.getProvider(userId)
0    print("entered providerManager.getProvider")

0    local stmt = DB:prepare("SELECT * FROM Providers WHERE provider_id = :provider_id")
0    stmt:bind_names({ provider_id = userId })
0    local result = dbUtils.queryOne(stmt)

0    if result then
0       return result, ""
     else
0       return {}, "Provider not found"
     end
  end

0 function providerManager.pushActiveRequests(providerIds, requestId, challenge)
0    print("entered providerManager.pushActiveRequests")
0    local success = true
0    local err = ""

0    for _, value in ipairs(providerIds) do
0       local provider = providerManager.getProvider(value)

0       if not provider then
0          print("Provider with ID " .. value .. " not found.")
0          success = false
0          err = err .. " " .. value
0          return success, err
        end

0       if challenge == true then
           local active_challenge_requests
0          if provider.active_challenge_requests then

0             active_challenge_requests = json.decode(provider.active_challenge_requests)
           else

0             active_challenge_requests = { request_ids = {} }
           end


0          table.insert(active_challenge_requests.request_ids, requestId)


0          local stringified_requests = json.encode(active_challenge_requests)

0          local stmt = DB:prepare([[
          UPDATE Providers
          SET active_challenge_requests = :active_challenge_requests
          WHERE provider_id = :provider_id;
0       ]])
0          stmt:bind_names({ provider_id = provider.provider_id, active_challenge_requests = stringified_requests })

0          local ok = pcall(function()
0             dbUtils.execute(stmt, "Failed to update provider active challenge requests")
           end)

0          if not ok then
0             print("Failed to update provider active challenge requests for provider ID " .. provider.provider_id)
0             success = false
0             err = err .. " " .. provider.provider_id
0             return success, err
           end
        else
0          print("made here")
           local active_output_requests
0          if provider.active_output_requests then

0             active_output_requests = json.decode(provider.active_output_requests)
           else

0             active_output_requests = { request_ids = {} }
           end


0          table.insert(active_output_requests.request_ids, requestId)


0          local stringified_requests = json.encode(active_output_requests)

0          local stmt = DB:prepare([[
          UPDATE Providers
          SET active_output_requests = :active_output_requests
          WHERE provider_id = :provider_id;
0       ]])
0          stmt:bind_names({ provider_id = provider.provider_id, active_output_requests = stringified_requests })

0          local ok = pcall(function()
0             dbUtils.execute(stmt, "Failed to update provider active output requests")
           end)

0          if not ok then
0             print("Failed to update provider active output requests for provider ID " .. provider.provider_id)
0             success = false
0             err = err .. " " .. provider.provider_id
0             return success, err
           end
        end
     end
  end

0 function providerManager.removeActiveRequest(provider_id, requestId, challenge)
0    print("entered providerManager.removeActiveRequest")


0    local provider = providerManager.getProvider(provider_id)
0    if not provider then
0       print("Provider with ID " .. provider_id .. " not found.")
0       return false, "Provider not found"
     end

0    if challenge then

        local active_challenge_requests
0       if provider.active_challenge_requests then
0          active_challenge_requests = json.decode(provider.active_challenge_requests)
        else
0          active_challenge_requests = { request_ids = {} }
        end


0       for i, id in ipairs(active_challenge_requests.request_ids) do
0          if id == requestId then
0             table.remove(active_challenge_requests.request_ids, i)
              break
           end
        end


0       local stringified_requests = json.encode(active_challenge_requests)


0       local stmt = DB:prepare([[
          UPDATE Providers
          SET active_challenge_requests = :active_challenge_requests
          WHERE provider_id = :provider_id;
0     ]])
0       stmt:bind_names({ provider_id = provider_id, active_challenge_requests = stringified_requests })

0       local ok = pcall(function()
0          dbUtils.execute(stmt, "Failed to update provider active challenge requests")
        end)

0       if not ok then
0          print("Failed to update provider active challenge requests for provider ID " .. provider_id)
0          return false, "Failed to update provider active challenge requests"
        end
     else

        local active_output_requests
0       if provider.active_output_requests then
0          active_output_requests = json.decode(provider.active_output_requests)
        else
0          active_output_requests = { request_ids = {} }
        end


0       for i, id in ipairs(active_output_requests.request_ids) do
0          if id == requestId then
0             table.remove(active_output_requests.request_ids, i)
              break
           end
        end


0       local stringified_requests = json.encode(active_output_requests)


0       local stmt = DB:prepare([[
          UPDATE Providers
          SET active_output_requests = :active_output_requests
          WHERE provider_id = :provider_id;
0     ]])
0       stmt:bind_names({ provider_id = provider_id, active_output_requests = stringified_requests })

0       local ok = pcall(function()
0          dbUtils.execute(stmt, "Failed to update provider active output requests")
        end)

0       if not ok then
0          print("Failed to update provider active output requests for provider ID " .. provider_id)
0          return false, "Failed to update provider active output requests"
        end
     end

0    return true, "Request ID removed successfully"
  end

0 function providerManager.getActiveRequests(userId, challenge)
0    print("entered providerManager.getActiveRequests")
0    local provider = providerManager.getProvider(userId)
0    if challenge then
0       if provider.active_challenge_requests then
0          return provider.active_challenge_requests, ""
        else
0          return "", "No active challenge requests found"
        end
     else
0       if provider.active_output_requests then
0          return provider.active_output_requests, ""
        else
0          return "", "No active output requests found"
        end
     end
  end

0 function providerManager.hasActiveRequest(userId, requestId, challenge)
0    print("entered providerManager.hasActiveRequest")

0    local activeRequests, err = providerManager.getActiveRequests(userId, challenge)
0    if err == "" then
0       local requestIds = json.decode(activeRequests)
0       for _, request_id in ipairs(requestIds.request_ids) do
0          if request_id == requestId then
0             return true
           end
        end
0       return false
     else
0       return false
     end
  end

0 function providerManager.checkStakeStubbed(_userId)
0    print("entered providerManager.checkStakeStubbed")
0    return true, ""
  end

0 function providerManager.checkStake(userId)
0    print("entered providerManager.checkStake")

0    local provider, _ = providerManager.getProvider(userId)
0    if provider.stake < RequiredStake then
0       return false, "Stake is less than required"
     else
0       return true, ""
     end
  end

0 function providerManager.updateProviderBalance(userId, balance)
0    print("entered providerManager.updateProviderBalance")

0    local stmt = DB:prepare([[
      UPDATE Providers
      SET random_balance = :balance
      WHERE provider_id = :provider_id;
0   ]])
0    stmt:bind_names({ provider_id = userId, balance = balance })

0    local ok = pcall(function()
0       dbUtils.execute(stmt, "Failed to update provider balance")
     end)

0    if ok then
0       return true, ""
     else
0       return false, "Failed to update provider balance"
     end
  end

0 function providerManager.updateProviderStatus(userId, active)
0    print("entered providerManager.updateProviderStatus")

     local stmt
0    local status = active and 1 or 0

0    stmt = DB:prepare([[
      UPDATE Providers
      SET active = :active
      WHERE provider_id = :provider_id;
0   ]])

0    stmt:bind_names({ provider_id = userId, active = status })

0    local ok = pcall(function()
0       dbUtils.execute(stmt, "Failed to update Provider status")
     end)

0    if ok then
0       return true, ""
     else
0       return false, "Failed to update Provider status"
     end
  end

0 return providerManager
  end
  end

  do
0 local _ENV = _ENV
0 package.preload[ "randomManager" ] = function( ... ) local arg = _G.arg;
0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local math = _tl_compat and _tl_compat.math or math; local os = _tl_compat and _tl_compat.os or os; local pcall = _tl_compat and _tl_compat.pcall or pcall; local string = _tl_compat and _tl_compat.string or string; local table = _tl_compat and _tl_compat.table or table; require("globals")
0 local json = require("json")
0 local dbUtils = require("dbUtils")
0 local providerManager = require("providerManager")
0 local verifierManager = require("verifierManager")


0 ProviderVDFResult = {}









0 RandomRequest = {}










0 RandomStatus = {}



0 ProvidersValue = {}



0 RequestedInputs = {}



0 ProviderVDFResults = {}



0 RandomResponseResponse = {}




0 local randomManager = {}

0 function randomManager.generateUUID()
0    print("entered randomManager.generateUUID")

0    local template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
0    return (string.gsub(template, '[xy]', function(c)
0       local v = (c == 'x') and math.random(0, 0xf) or math.random(8, 0xb)
0       return string.format('%x', v)
     end))
  end

0 function randomManager.getRandomProviderList(requestId)
0    print("entered randomManager.getRandomProviders")

0    local stmt = DB:prepare("SELECT providers FROM RandomRequests WHERE request_id = :request_id")
0    stmt:bind_names({ request_id = requestId })
0    local result = dbUtils.queryOne(stmt)

0    if result then
0       return json.decode(result.providers), ""
     else
0       return {}, "RandomRequest providers not found"
     end
  end

0 function randomManager.updateRandomRequestStatus(requestId, newStatus)
0    print("Entered randomManager.updateRandomRequestStatus")


0    local validStatus = false
0    for _, status in ipairs(Status) do
0       if newStatus == status then
0          validStatus = true
           break
        end
     end

0    if not validStatus then
0       return false, "Failure: Invalid status: " .. tostring(newStatus)
     end


0    local stmt = DB:prepare([[
      UPDATE RandomRequests
      SET status = :status
      WHERE request_id = :request_id;
0   ]])

0    if not stmt then
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end


0    stmt:bind_names({ status = newStatus, request_id = requestId })


0    local execute_ok, execute_err = dbUtils.execute(stmt, "Update random request status")

0    if not execute_ok then
0       return false, "Failed to update random request status: " .. tostring(execute_err)
     end

0    print("Random request status updated successfully to: " .. newStatus)
0    return true, ""
  end

0 function randomManager.getRandomRequestedInputs(requestId)
0    print("entered randomManager.getRandomRequestedInputs")

0    local stmt = DB:prepare("SELECT requested_inputs FROM RandomRequests WHERE request_id = :request_id")
0    stmt:bind_names({ request_id = requestId })
0    local result = dbUtils.queryOne(stmt)
0    if result then
0       return result.requested_inputs, ""
     else
0       return nil, "RandomRequest requested_inputs not found"
     end
  end

0 function randomManager.getRandomStatus(requestId)
0    print("entered randomManager.getRandomStatus")

0    local stmt = DB:prepare("SELECT status FROM RandomRequests WHERE request_id = :request_id")
0    stmt:bind_names({ request_id = requestId })
0    local result = dbUtils.queryOne(stmt)
0    if result then
0       return result.status, ""
     else
0       return "", "RandomRequest status not found"
     end
  end

0 function randomManager.resetRandomRequestRequestedInputs(requestId, newRequestedInputs)
0    print("Entered randomManager.resetRandomRequestRequestedInputs")


0    local stmt = DB:prepare([[
      UPDATE RandomRequests
      SET requested_inputs = :requested_inputs
      WHERE request_id = :request_id;
0   ]])
0    if not stmt then
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end


0    stmt:bind_names({ requested_inputs = newRequestedInputs, request_id = requestId })


0    local execute_ok, execute_err = dbUtils.execute(stmt, "Update random request requested inputs")

0    if not execute_ok then
0       return false, "Failed to update random request requested inputs: " .. tostring(execute_err)
     end

0    print("Random request requested inputs updated successfully to: " .. newRequestedInputs)
0    return true, ""
  end

0 function randomManager.getVDFResults(requestId)
0    print("entered randomManager.getVDFResults")

0    local stmt = DB:prepare("SELECT * FROM ProviderVDFResults WHERE request_id = :request_id")
0    stmt:bind_names({ request_id = requestId })
0    local queryResult = dbUtils.queryMany(stmt)
0    print(json.encode(queryResult))
0    print(json.encode(queryResult[1]))
0    local result = {
        requestResponses = {},
     }

0    for _, response in ipairs(queryResult) do
0       table.insert(result.requestResponses, response)
     end

0    print(json.encode(result))

0    if result then
0       return result, ""
     else
0       return {}, "RandomRequest not found"
     end
  end

0 function randomManager.getRandomRequest(requestId)
0    print("entered randomManager.getRandomRequest")

0    local stmt = DB:prepare("SELECT * FROM RandomRequests WHERE request_id = :request_id")
0    stmt:bind_names({ request_id = requestId })
0    local result = dbUtils.queryOne(stmt)
0    if result then
0       return result, ""
     else
0       return {}, "RandomRequest not found"
     end
  end


0 function randomManager.processEntropy(requestId)
0    print("entered randomManager.processEntropy")

0    local results, err = randomManager.getVDFResults(requestId)
0    if err ~= "" then
0       print("Failed to get VDF results: " .. err)
0       return "", err
     end

0    results = results


0    local mixed = tonumber(results.requestResponses[1].output_value)


0    for i = 2, #results.requestResponses do
0       local value = tonumber(results.requestResponses[i].output_value)
0       if not value then
0          print("Invalid output_value at index " .. i .. ": " .. tostring(results.requestResponses[i].output_value))
0          return "", "Invalid output_value in requestResponses"
        end

0       mixed = (mixed ~ (value >> 32) ~ (value & 0xFFFFFFFF))

0       mixed = (mixed * 0x5bd1e995 + value) % (2 ^ 31 - 1)
     end

0    local entropy = tostring(math.floor(mixed))
0    print("entropy: " .. entropy)
0    return entropy, ""
  end

0 function randomManager.simulateRandomResponse(requestId)
0    print("entered simulateRandomResponse")

0    local randomRequest, err = randomManager.getRandomRequest(requestId)

0    if err ~= "" then
0       print("Failed to get random request: " .. err)
0       return false
     end

0    local target = randomRequest.requester
0    local callbackId = randomRequest.callback_id
0    local entropy = randomManager.processEntropy(requestId)
0    local action = "Random-Response"

0    local data = {
        callbackId = callbackId,
        entropy = entropy,
     }

0    ao.send({
        Target = target,
0       Tags = {
           Action = action,
        },
        Data = data,
     })
  end

0 function randomManager.decrementRequestedInputs(requestId)
0    print("Entered randomManager.decrementRequestedInputs")

0    local requested, _ = randomManager.getRandomRequestedInputs(requestId)

0    if requested == 0 then
0       return false, "Failure: can not decrement needed below 0"
     end

0    print("Requested: " .. requested)

0    requested = requested - 1

0    local stmt = DB:prepare([[
      UPDATE RandomRequests
      SET requested_inputs = :requested_inputs
      WHERE request_id = :request_id;
0   ]])

0    if not stmt then
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end


0    stmt:bind_names({ requested_inputs = requested, request_id = requestId })


0    local execute_ok, execute_err = dbUtils.execute(stmt, "Update random request requested_inputs")

0    if not execute_ok then
0       return false, "Failed to update random request requested_inputs: " .. tostring(execute_err)
     end

0    if requested == 0 then
0       local status, err = randomManager.getRandomStatus(requestId)

0       if err == "" then

0          if status == Status[1] then
0             print("Random request finished collecting inputs")
0             local providerList = randomManager.getRandomProviderList(requestId)
0             randomManager.resetRandomRequestRequestedInputs(requestId, #providerList.provider_ids)
0             providerManager.pushActiveRequests(providerList.provider_ids, requestId, false)
0             randomManager.updateRandomRequestStatus(requestId, Status[2])

0          elseif status == Status[2] then
0             print("Random request finished collecting outputs")
0             local providerList = randomManager.getRandomProviderList(requestId)
0             local requestedValue = #providerList.provider_ids * 11
0             randomManager.resetRandomRequestRequestedInputs(requestId, requestedValue)
0             randomManager.updateRandomRequestStatus(requestId, Status[3])

0          elseif status == Status[3] then
0             print("Random request finished successfully")
0             randomManager.simulateRandomResponse(requestId)
0             randomManager.updateRandomRequestStatus(requestId, Status[5])
           end
        else
0          return false, err
        end
     end

0    print("Random request requested_inputs updated successfully to: " .. requested)
0    return true, ""
  end

0 function randomManager.getRandomRequestViaCallbackId(callbackId)
0    print("entered randomManager.getRandomRequestViaCallbackId")

0    local stmt = DB:prepare("SELECT * FROM RandomRequests WHERE callback_id = :callback_id")
0    stmt:bind_names({ callback_id = callbackId })
0    local result = dbUtils.queryOne(stmt)
0    if result then
0       return result, ""
     else
0       return {}, "RandomRequest not found"
     end
  end

0 function randomManager.getVDFResult(requestId, providerId)
0    print("entered randomManager.getVDFResult")

0    local stmt = DB:prepare("SELECT * FROM ProviderVDFResults WHERE request_id = :request_id AND provider_id = :provider_id")
0    stmt:bind_names({ request_id = requestId, provider_id = providerId })
0    local result = dbUtils.queryOne(stmt)
0    if result then
0       return result, ""
     else
0       return {}, "RandomRequest not found"
     end
  end

0 function randomManager.createRandomRequest(userId, providers, callbackId, requestedInputs)
0    print("entered randomManager.createRandomRequest")

0    local timestamp = os.time()
0    local requestId = randomManager.generateUUID()


0    local providerList = json.decode(providers)
0    if not providerList or not providerList.provider_ids or #providerList.provider_ids == 0 then
0       return false, "Invalid providers list"
     end

0    local decodedRequestList = {}

0    if requestedInputs ~= "" then

0       local result = json.decode(requestedInputs)

0       if result and type(result) == "table" then
0          decodedRequestList = result
        else
0          print("Failed to decode requestedInputs. Invalid JSON or structure.")
0          return false, "Invalid requestedInputs JSON"
        end
     else

0       decodedRequestList = {}
     end


0    local requestedValue = math.min(decodedRequestList.requested_inputs or #providerList.provider_ids, #providerList.provider_ids)

0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    providerManager.pushActiveRequests(providerList.provider_ids, requestId, true)

0    print("Preparing SQL statement for random request creation")
0    local stmt = DB:prepare([[
      INSERT OR IGNORE INTO RandomRequests (request_id, requester, callback_id, providers, requested_inputs, status, created_at)
      VALUES (:request_id, :requester, :callback_id, :providers, :requested_inputs, :status, :created_at);
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local status = Status[1]

0    print("Binding parameters for random request creation")
0    local bind_ok, bind_err = pcall(function()
0       stmt:bind_names({ request_id = requestId, requester = userId, callback_id = callbackId, providers = providers, requested_inputs = requestedValue, status = status, created_at = timestamp })
     end)

0    if not bind_ok then
0       print("Failed to bind parameters: " .. tostring(bind_err))
0       stmt:finalize()
0       return false, "Failed to bind parameters: " .. tostring(bind_err)
     end

0    print("Executing random request creation statement")
0    local execute_ok, execute_err = dbUtils.execute(stmt, "Create random request")

0    if not execute_ok then
0       print("Random Request creation failed: " .. execute_err)
     else
0       print("Random Request created successfully")
0       print("New RequestId: " .. requestId)
     end

0    return execute_ok, execute_err
  end

0 function randomManager.postVDFChallenge(userId, requestId, inputValue, modulusValue)
0    print("entered randomManager.postVDFChallenge")

0    local timestamp = os.time()

0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    print("Preparing SQL statement for provider request response creation")
0    local stmt = DB:prepare([[
      INSERT OR IGNORE INTO ProviderVDFResults (request_id, provider_id, input_value, modulus_value, created_at)
      VALUES (:request_id, :provider_id, :input_value, :modulus_value, :created_at);
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    print("Binding parameters for provider request response creation")
0    local bind_ok, bind_err = pcall(function()
0       stmt:bind_names({ request_id = requestId, provider_id = userId, input_value = inputValue, modulus_value = modulusValue, created_at = timestamp })
     end)

0    if not bind_ok then
0       print("Failed to bind parameters: " .. tostring(bind_err))
0       stmt:finalize()
0       return false, "Failed to bind parameters: " .. tostring(bind_err)
     end

0    print("Executing provider request response creation statement")
0    local execute_ok, execute_err = dbUtils.execute(stmt, "Create provider request response")

0    if not execute_ok then
0       print("Provider Request Response creation failed: " .. execute_err)
     else
0       print("Provider Request Response created successfully")
     end

0    return execute_ok, execute_err
  end

0 function randomManager.postVDFOutputAndProof(userId, requestId, outputValue, proof)
0    print("entered randomManager.postVDFOutputAndProof")

0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    print("Preparing SQL statement for provider request response creation")
0    local stmt = DB:prepare([[
      UPDATE ProviderVDFResults
      SET output_value = :output_value, proof = :proof
      WHERE request_id = :request_id AND provider_id = :provider_id;
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    print("Binding parameters for provider request response creation")
0    local bind_ok, bind_err = pcall(function()
0       stmt:bind_names({ request_id = requestId, provider_id = userId, output_value = outputValue, proof = proof })
     end)

0    if not bind_ok then
0       print("Failed to bind parameters: " .. tostring(bind_err))
0       stmt:finalize()
0       return false, "Failed to bind parameters: " .. tostring(bind_err)
     end

0    print("Executing post vdf output and proof statement")
0    local execute_ok, execute_err = dbUtils.execute(stmt, "Post vdf output and proof")

0    if not execute_ok then
0       print("Post VDF Output and Proof failed: " .. execute_err)
     else
0       print("VDF Output and Proof posted successfully")


0       local vdfRequest = randomManager.getVDFResult(requestId, userId)
0       local input = vdfRequest.input_value
0       local modulus = vdfRequest.modulus_value


0       local processResult, processError = verifierManager.processProof(requestId, input, modulus, proof, userId, outputValue)
0       if not processResult then
0          print("Processing proof failed: " .. tostring(processError))
        else
0          print("Proof processed successfully")
        end

     end

0    return execute_ok, execute_err
  end

0 return randomManager
  end
  end

  do
0 local _ENV = _ENV
0 package.preload[ "tokenManager" ] = function( ... ) local arg = _G.arg;
0 local tokenManager = {}

0 function tokenManager.sendTokens(token, recipient, quantity, note)
0    ao.send({
        Target = token,
        Action = "Transfer",
        Recipient = recipient,
        Quantity = quantity,
        ["X-Note"] = note or "Sending tokens from Random Process",
     })
  end

0 function tokenManager.returnTokens(msg, errMessage)
0    tokenManager.sendTokens(msg.From, msg.Sender, msg.Quantity, errMessage)
  end

0 return tokenManager
  end
  end

  do
0 local _ENV = _ENV
0 package.preload[ "verifierManager" ] = function( ... ) local arg = _G.arg;
0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local os = _tl_compat and _tl_compat.os or os; local pcall = _tl_compat and _tl_compat.pcall or pcall; local table = _tl_compat and _tl_compat.table or table
0 require("globals")
0 local dbUtils = require("dbUtils")
0 local json = require("json")


0 VerifierProcess = {}





0 VerifierSegment = {}









0 Proof = {}



0 VerifierStats = {}




0 VDFRequestData = {}








0 VDFRequestResponse = {}





0 local verifierManager = {}


0 function verifierManager.registerVerifier(processId)
0    print("Registering verifier: " .. processId)

0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      INSERT OR REPLACE INTO Verifiers
      (process_id, status)
      VALUES (:pid, 'available')
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({ pid = processId })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return false, "Failed to bind parameters"
     end

0    local exec_ok, exec_err = dbUtils.execute(stmt, "Register verifier")
0    if not exec_ok then
0       return false, exec_err
     end

0    return true, ""
  end


0 function verifierManager.getAvailableVerifiers()
0    if not DB then
0       print("Database connection not initialized")
0       return {}, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      SELECT * FROM Verifiers
      WHERE status = 'available'
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return {}, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local rows = dbUtils.queryMany(stmt)
0    local verifiers = {}

0    for _, row in ipairs(rows) do
0       local verifier = {
           process_id = tostring(row.process_id),
           status = tostring(row.status),
           current_segment = row.current_segment and tostring(row.current_segment) or "",
        }
0       table.insert(verifiers, verifier)
     end

0    return verifiers, ""
  end


0 function verifierManager.getStats()
0    local stats = {
        total_available = 0,
        total_busy = 0,
     }

0    if not DB then
0       print("Database connection not initialized")
0       return stats
     end

0    local stmt = DB:prepare([[
      SELECT
        COUNT(CASE WHEN status = 'available' THEN 1 END) as available,
        COUNT(CASE WHEN status = 'busy' THEN 1 END) as busy
      FROM Verifiers
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return stats
     end

0    local row = dbUtils.queryOne(stmt)
0    if row then
0       stats.total_available = tonumber(row.available) or 0
0       stats.total_busy = tonumber(row.busy) or 0
     end

0    return stats
  end

0 function verifierManager.requestVerification(processId, data, checkpoint)
0    print("Sending verification request to process: " .. processId)

0    if checkpoint then
0       local _ = ao.send({
           Target = processId,
           Action = "Validate-Checkpoint",
           Data = json.encode(data),
        })
0       return
     else
0       local _ = ao.send({
           Target = processId,
           Action = "Validate-Output",
           Data = json.encode(data),
        })
     end
  end


0 function verifierManager.assignSegment(verifierId, segmentId)
0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      UPDATE Verifiers
      SET status = 'busy', current_segment = :segment
      WHERE process_id = :pid AND status = 'available'
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({
           pid = verifierId,
           segment = segmentId,
        })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return false, "Failed to bind parameters"
     end

0    local exec_ok, exec_err = dbUtils.execute(stmt, "Assign segment")
0    if not exec_ok then
0       return false, exec_err
     end

0    return true, ""
  end


0 function verifierManager.markAvailable(verifierId)
0    print("Marking verifier as available: " .. verifierId)
0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      UPDATE Verifiers
      SET status = 'available', current_segment = NULL
      WHERE process_id = :pid
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({ pid = verifierId })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return false, "Failed to bind parameters"
     end

0    local exec_ok, exec_err = dbUtils.execute(stmt, "Mark verifier available")
0    if not exec_ok then
0       return false, exec_err
     end

0    return true, ""
  end


0 function verifierManager.processVerification(verifierId, requestId, segmentId, result)
0    print("Processing verification result for segment: " .. segmentId)
0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      UPDATE VerifierSegments
      SET status = 'processed', result = :result
      WHERE segment_id = :sid
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({
           sid = segmentId,
           result = result,
        })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return false, "Failed to bind parameters"
     end

0    local exec_ok, exec_err = dbUtils.execute(stmt, "Process result")
0    if not exec_ok then
0       return false, exec_err
     end

0    verifierManager.markAvailable(verifierId)

0    return true, ""
  end


0 function verifierManager.createSegment(proofId, segmentCount, segmentData)
0    if not DB then
0       print("Database connection not initialized")
0       return "", "Database connection is not initialized"
     end

0    local timestamp = os.time()
0    local segmentId = proofId .. "_" .. segmentCount

0    local stmt = DB:prepare([[
      INSERT INTO VerifierSegments
      (segment_id, proof_id, segment_data, status, timestamp)
      VALUES (:sid, :pid, :data, 'pending', :time)
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return "", "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({
           sid = segmentId,
           pid = proofId,
           data = segmentData,
           time = timestamp,
        })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return "", "Failed to bind parameters"
     end

0    local exec_ok, exec_err = dbUtils.execute(stmt, "Create segment")
0    if not exec_ok then
0       return "", exec_err
     end

0    return segmentId, ""
  end


0 function verifierManager.updateSegmentStatus(segmentId, status, result)
0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      UPDATE VerifierSegments
      SET status = :status, result = :result
      WHERE segment_id = :sid
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({
           sid = segmentId,
           status = status,
           result = result,
        })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return false, "Failed to bind parameters"
     end

0    local exec_ok, exec_err = dbUtils.execute(stmt, "Update segment status")
0    if not exec_ok then
0       return false, exec_err
     end

0    return true, ""
  end


0 function verifierManager.getProofSegments(proofId, expectedOutput)
0    if not DB then
0       print("Database connection not initialized")
0       return {}, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      SELECT * FROM VerifierSegments
      WHERE proof_id = :pid
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return {}, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({ pid = proofId })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return {}, "Failed to bind parameters"
     end

0    local rows = dbUtils.queryMany(stmt)
0    local segments = {}

0    for _, row in ipairs(rows) do
0       local segment = {
           segment_id = tostring(row.segment_id),
           proof_id = tostring(row.proof_id),
           verifier_id = row.verifier_id and tostring(row.verifier_id) or "",
           segment_data = tostring(row.segment_data),
           status = tostring(row.status),
           timestamp = tonumber(row.timestamp) or 0,
           result = row.result and tostring(row.result) or "",
        }
0       table.insert(segments, segment)
     end

0    return segments, ""
  end


0 function verifierManager.processProof(requestId, input, modulus, proofJson, providerId, modExpectedOutput)

0    local proofArray = json.decode(proofJson)
0    if not proofArray then
0       return false, "Failed to parse proof JSON"
     end


0    local proof = { proof = proofArray }

0    local proofId = requestId .. "_" .. providerId
0    local availableVerifiers = verifierManager.getAvailableVerifiers()





0    local outputSegmentId, segmentCreateErr = verifierManager.createSegment(proofId, "output", modExpectedOutput)

0    if segmentCreateErr ~= "" then
0       return false, "Failed to create segment: " .. segmentCreateErr
     end

0    local outputVerifierId = availableVerifiers[1]
0    table.remove(availableVerifiers, 1)

0    local assigned, assignErr = verifierManager.assignSegment(outputVerifierId.process_id, outputSegmentId)
0    if not assigned then
0       print("Failed to assign segment: " .. assignErr)
     else
0       local outputSegmentInput = proofArray[10]
0       local segmentExpectedOutput = modExpectedOutput

0       local requestData = {
           request_id = requestId,
           segment_id = outputSegmentId,
           input = outputSegmentInput,
           expected_output = segmentExpectedOutput,
        }

0       verifierManager.requestVerification(outputVerifierId.process_id, requestData, false)
     end



0    local segmentCount = 1
0    for _, segment in ipairs(proof.proof) do
0       print("Processing segment: " .. segment .. " count: " .. segmentCount)

0       local segmentId, createErr = verifierManager.createSegment(proofId, tostring(segmentCount), segment)
0       segmentCount = segmentCount + 1

0       if createErr ~= "" then
0          return false, "Failed to create segment: " .. createErr
        end

0       if #availableVerifiers > 0 then
0          local verifierId = availableVerifiers[1]
0          table.remove(availableVerifiers, 1)

0          local assigned, assignErr = verifierManager.assignSegment(verifierId.process_id, segmentId)
0          if not assigned then
0             print("Failed to assign segment: " .. assignErr)
           else
0             local segmentInput = input
0             local segmentExpectedOutput = proofArray[segmentCount - 1]

0             if segmentCount > 2 then
0                segmentInput = proofArray[segmentCount - 2]
              end

0             local requestData = {
                 request_id = requestId,
                 segment_id = segmentId,
                 checkpoint_input = segmentInput,
                 modulus = modulus,
                 expected_output = segmentExpectedOutput,
              }

0             verifierManager.requestVerification(verifierId.process_id, requestData, true)
           end
        else
0          print("No verifiers available for segment: " .. segmentId)
        end

     end

0    return true, ""
  end


0 function verifierManager.removeVerifier(processId)
0    print("Removing verifier: " .. processId)

0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      DELETE FROM Verifiers
      WHERE process_id = :pid
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({ pid = processId })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return false, "Failed to bind parameters"
     end

0    local exec_ok, exec_err = dbUtils.execute(stmt, "Remove verifier")
0    if not exec_ok then
0       return false, exec_err
     end

0    return true, ""
  end

0 function verifierManager.initializeVerifierManager()
0    for _, verifier in ipairs(VerifierProcesses) do
0       verifierManager.registerVerifier(verifier)
     end
0    print("Verifier manager and processes initialized")
  end

0 return verifierManager
  end
  end

0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local debug = _tl_compat and _tl_compat.debug or debug; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local math = _tl_compat and _tl_compat.math or math; local table = _tl_compat and _tl_compat.table or table; local xpcall = _tl_compat and _tl_compat.xpcall or xpcall
0 require("globals")
0 local json = require("json")
0 local database = require("database")
0 local providerManager = require("providerManager")
0 local randomManager = require("randomManager")
0 local tokenManager = require("tokenManager")
0 local verifierManager = require("verifierManager")


0 ResponseData = {}





0 ReplyData = {}




0 UpdateProviderRandomBalanceData = {}



0 PostVDFChallengeData = {}





0 PostVDFOutputAndProofData = {}





0 CheckpointResponseData = {}





0 GetProviderRandomBalanceData = {}



0 GetOpenRandomRequestsData = {}



0 GetRandomRequestsData = {}



0 GetRandomRequestViaCallbackIdData = {}



0 CreateRandomRequestData = {}





0 GetProviderRandomBalanceResponse = {}




0 GetOpenRandomRequestsResponse = {}





0 RandomRequestResponse = {}




0 GetRandomRequestsResponse = {}




0 database.initializeDatabase()


0 verifierManager.initializeVerifierManager()


0 function sendResponse(target, action, data)
0    return {
        Target = target,
        Action = action,
        Data = json.encode(data),
     }
  end


0 function sendReply(action, data)
0    return {
        Action = action,
        Data = json.encode(data),
     }
  end


  local function errorHandler(err)
0    print("Critical error occurred: " .. tostring(err))
0    print(debug.traceback())
  end


  local function wrapHandler(handlerFn)
     return function(msg)
0       local success = xpcall(function() return handlerFn(msg) end, errorHandler)
0       if not success then
0          if msg.Sender == nil then
0             ao.send(sendResponse(msg.From, "Error", { message = "An unexpected error occurred. Please try again later." }))
           else
0             ao.send(sendResponse(msg.Sender, "Error", { message = "An unexpected error occurred. Please try again later." }))
           end
        end
     end
  end


  local function createProvider(userid)
0    local success, _ = providerManager.createProvider(userid)
0    return success
  end


  local function infoHandler(msg)
0    ao.send(sendResponse(msg.From, "Info", {}))
  end


0 function updateProviderBalanceHandler(msg)
0    print("entered updateProviderBalance")

0    local userId = msg.From

0    createProvider(userId)

0    local staked, _ = providerManager.checkStakeStubbed(userId)

0    if not staked then
0       ao.send(sendResponse(msg.From, "Error", { message = "Update failed: Provider not staked" }))
0       return false
     end

0    local data = (json.decode(msg.Data))
0    local balance = data.availableRandomValues
0    local success, _err = providerManager.updateProviderBalance(userId, balance)

0    if success then

0       return true
     else

0       return false
     end
  end


0 function postVDFChallengeHandler(msg)
0    print("entered postVDFChallenge")

0    local userId = msg.From

0    local data = (json.decode(msg.Data))
0    local requestId = data.requestId
0    local modulus = data.modulus
0    local input = data.input

0    local requested = providerManager.hasActiveRequest(userId, requestId, true)

0    if not requested then
0       ao.send(sendResponse(msg.From, "Error", { message = "Failed to post VDF Input: " .. "not requested" }))
0       return false
     end

0    local success, _err = randomManager.postVDFChallenge(userId, requestId, input, modulus)

0    if success then
0       providerManager.removeActiveRequest(userId, requestId, true)
0       randomManager.decrementRequestedInputs(requestId)

0       return true
     else

0       return false
     end
  end


0 function postVDFOutputAndProofHandler(msg)
0    print("entered postVDFOutputAndProof")

0    local userId = msg.From

0    local data = (json.decode(msg.Data))
0    local output = data.output
0    local proof = data.proof

     local function validateInputs(_output, _proof)
0       return true
     end

0    if output == nil or proof == nil or not validateInputs(output, proof) then
0       ao.send(sendResponse(msg.From, "Error", { message = "Failed to post VDF Output: " .. "values not provided" }))
0       return false
     end

0    local requestId = data.requestId

0    local requested = providerManager.hasActiveRequest(userId, requestId, false)
0    if not requested then
0       ao.send(sendResponse(msg.From, "Error", { message = "Failed to post VDF Output: " .. "not requested" }))
0       return false
     end
0    providerManager.removeActiveRequest(userId, requestId, false)

0    local success, _err = randomManager.postVDFOutputAndProof(userId, requestId, output, proof)

0    if success then
0       randomManager.decrementRequestedInputs(requestId)

0       return true
     else


0       return false
     end
  end


0 function postVerificationHandler(msg)
0    print("entered postVerification")

0    local verifierId = msg.From

0    local data = (json.decode(msg.Data))

0    local valid = data.valid
0    local requestId = data.request_id
0    local segmentId = data.segment_id

     local function validateVerificationInputs(_valid, _requestId, _segmentId)
0       return true
     end

0    if valid == nil or segmentId == nil or requestId == nil or not validateVerificationInputs(valid, requestId, segmentId) then
0       print("Failed to post Verification: " .. "values not provided or malformed")
0       ao.send(sendResponse(msg.From, "Error", { message = "Failed to post Verification: " .. "values not provided or malformed" }))
0       return false
     end

0    local success, _err = verifierManager.processVerification(verifierId, requestId, segmentId, valid)

0    if success then
0       randomManager.decrementRequestedInputs(requestId)

0       return true
     else


0       return false
     end
  end


0 function getProviderRandomBalanceHandler(msg)
0    print("entered getProviderRandomBalance")

0    local data = (json.decode(msg.Data))
0    local providerId = data.providerId
0    local providerInfo, err = providerManager.getProvider(providerId)
0    local randomBalance = providerInfo.random_balance
0    if err == "" then
0       local responseData = { providerId = providerId, availibleRandomValues = randomBalance }
0       ao.send(sendResponse(msg.From, "Get-Providers-Random-Balance-Response", responseData))
0       return true
     else
0       ao.send(sendResponse(msg.From, "Error", { message = "Provider not found: " .. err }))
0       return false
     end
  end


0 function creditNoticeHandler(msg)
0    print("entered creditNotice")

0    local value = math.floor(tonumber(msg.Quantity))
0    local callbackId = msg.Tags["X-CallbackId"] or nil

0    if msg.From ~= TokenInUse then
0       local err = "Invalid Token Sent: " .. msg.From
0       print(err)
0       ao.send(sendResponse(msg.Sender, "Error", { message = err }))
0       tokenManager.returnTokens(msg, err)
0       return false
     end
0    if value < Cost then
0       local err = "Invalid Value Sent: " .. tostring(value)
0       print(err)
0       ao.send(sendResponse(msg.Sender, "Error", { message = err }))
0       tokenManager.returnTokens(msg, err)
0       return false
     end
0    if callbackId == nil then
0       local err = "Failure: No Callback ID provided"
0       print(err)
0       ao.send(sendResponse(msg.Sender, "Error", { message = err }))
0       tokenManager.returnTokens(msg, err)
0       return false
     end

0    local userId = msg.Sender
0    local providers = msg.Tags["X-Providers"] or nil
0    local requestedInputs = msg.Tags["X-RequestedInputs"] or ""

0    local success, err = randomManager.createRandomRequest(userId, providers, callbackId, requestedInputs)

0    if success then
0       ao.send(sendResponse(userId, "Created New Random Request", SuccessMessage))
0       return true
     else
0       ao.send(sendResponse(userId, "Error", { message = "Failed to create new random request: " .. err }))
0       return false
     end
  end


0 function getOpenRandomRequestsHandler(msg)
0    print("entered getOpenRandomRequests")

0    local data = (json.decode(msg.Data))
0    local providerId = data.providerId

0    local _, providerErr = providerManager.getProvider(providerId)

0    if providerErr ~= "" then
0       ao.send(sendResponse(msg.From, "Error", { message = "Provider not found" }))
0       return false
     end

0    local responseData = { providerId = providerId, activeChallengeRequests = { request_ids = {} }, activeOutputRequests = { request_ids = {} } }

0    local activeChallengeRequests, err = providerManager.getActiveRequests(providerId, true)
0    local activeOutputRequests, outputErr = providerManager.getActiveRequests(providerId, false)

0    if err == "" then
0       local requestIds = json.decode(activeChallengeRequests)
0       responseData.activeChallengeRequests = requestIds
     end
0    if outputErr == "" then
0       local requestIds = json.decode(activeOutputRequests)
0       responseData.activeOutputRequests = requestIds
     end

0    ao.send(sendResponse(msg.From, "Get-Open-Random-Requests-Response", responseData))
0    return true
  end


0 function getRandomRequestsHandler(msg)
0    print("entered getRandomRequests")

0    local data = (json.decode(msg.Data))
0    local responseData = { randomRequestResponses = {} }

0    for _, request_id in ipairs(data.requestIds) do
0       local requestResponse = {
           randomRequest = nil,
           providerVDFResults = nil,
        }
0       local request, requestErr = randomManager.getRandomRequest(request_id)
0       if requestErr == "" then
0          requestResponse.randomRequest = request
0          local providerVDFResults, resultsErr = randomManager.getVDFResults(request_id)
0          if resultsErr == "" then
0             requestResponse.providerVDFResults = providerVDFResults
           end
        end
0       table.insert(responseData.randomRequestResponses, requestResponse)
     end

0    ao.send(sendResponse(msg.From, "Get-Random-Requests-Response", responseData))
0    return true
  end


0 function getRandomRequestViaCallbackIdHandler(msg)
0    print("entered getRandomRequestViaCallbackId")

0    local data = (json.decode(msg.Data))
0    local callback_id = data.callbackId
0    local responseData = { randomRequestResponses = {} }

0    local requestResponse = {
        randomRequest = nil,
        providerVDFResults = nil,
     }
0    local request, requestErr = randomManager.getRandomRequestViaCallbackId(callback_id)
0    local request_id = request.request_id

0    if requestErr == "" then
0       requestResponse.randomRequest = request
0       local providerVDFResults, resultsErr = randomManager.getVDFResults(request_id)
0       if resultsErr == "" then
0          requestResponse.providerVDFResults = providerVDFResults
        end
     end
0    table.insert(responseData.randomRequestResponses, requestResponse)
0    msg.reply({ Data = json.encode(responseData) })


0    return true
  end


0 Handlers.add('info',
0 Handlers.utils.hasMatchingTag('Action', 'Info'),
0 wrapHandler(infoHandler))

0 Handlers.add('updateProviderBalance',
0 Handlers.utils.hasMatchingTag('Action', 'Update-Providers-Random-Balance'),
0 wrapHandler(updateProviderBalanceHandler))

0 Handlers.add('postVDFChallenge',
0 Handlers.utils.hasMatchingTag('Action', 'Post-VDF-Challenge'),
0 wrapHandler(postVDFChallengeHandler))

0 Handlers.add('postVDFOutputAndProof',
0 Handlers.utils.hasMatchingTag('Action', 'Post-VDF-Output-And-Proof'),
0 wrapHandler(postVDFOutputAndProofHandler))

0 Handlers.add('postVerification',
0 Handlers.utils.hasMatchingTag('Action', 'Post-Verification'),
0 wrapHandler(postVerificationHandler))

0 Handlers.add('getProviderRandomBalance',
0 Handlers.utils.hasMatchingTag('Action', 'Get-Providers-Random-Balance'),
0 wrapHandler(getProviderRandomBalanceHandler))

0 Handlers.add('creditNotice',
0 Handlers.utils.hasMatchingTag('Action', 'Credit-Notice'),
0 wrapHandler(creditNoticeHandler))

0 Handlers.add('getOpenRandomRequests',
0 Handlers.utils.hasMatchingTag('Action', 'Get-Open-Random-Requests'),
0 wrapHandler(getOpenRandomRequestsHandler))

0 Handlers.add('getRandomRequests',
0 Handlers.utils.hasMatchingTag('Action', 'Get-Random-Requests'),
0 wrapHandler(getRandomRequestsHandler))

0 Handlers.add('getRandomRequestViaCallbackId',
0 Handlers.utils.hasMatchingTag('Action', 'Get-Random-Request-Via-Callback-Id'),
0 wrapHandler(getRandomRequestViaCallbackIdHandler))


0 print("RandAO Process Initialized")

==============================================================================
scripts/copy_lua_package.lua
==============================================================================
0 local lfs = require("lfs") -- LuaFileSystem for directory operations

  local function copy_directory(src, dest)
      -- Ensure the destination directory exists
0     local attr = lfs.attributes(dest)
0     if not attr then
0         lfs.mkdir(dest)
      end

0     for file in lfs.dir(src) do
0         if file ~= "." and file ~= ".." then
0             local src_path = src .. '/' .. file
0             local dest_path = dest .. '/' .. file
0             local attr = lfs.attributes(src_path)
0             if attr.mode == "directory" then
0                 lfs.mkdir(dest_path)
0                 copy_directory(src_path, dest_path)
              else
0                 local src_file = io.open(src_path, "rb")
0                 if not src_file then
0                     error("Failed to open source file: " .. src_path)
                  end
0                 local dest_file = io.open(dest_path, "wb")
0                 if not dest_file then
0                     src_file:close()
0                     error("Failed to open destination file: " .. dest_path)
                  end
0                 dest_file:write(src_file:read("*all"))
0                 src_file:close()
0                 dest_file:close()
              end
          end
      end
  end

0 lfs.mkdir('./build-lua/')
0 copy_directory('./packages/', './build-lua/')

==============================================================================
build/dbUtils.lua
==============================================================================
0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local pcall = _tl_compat and _tl_compat.pcall or pcall; local table = _tl_compat and _tl_compat.table or table; require("globals")

0 local sqlite3 = require('lsqlite3')
0 local dbUtils = {}

0 function dbUtils.queryMany(stmt)
0    local rows = {}

0    if stmt then
0       for row in stmt:nrows() do
0          table.insert(rows, row)
        end
0       stmt:finalize()
     else
0       error("Err: " .. DB:errmsg())
     end
0    return rows
  end

0 function dbUtils.queryOne(stmt)
0    return dbUtils.queryMany(stmt)[1]
  end

0 function dbUtils.rawQuery(query)
0    local stmt = DB:prepare(query)
0    if not stmt then
0       error("Err: " .. DB:errmsg())
     end
0    return dbUtils.queryMany(stmt)
  end

0 function dbUtils.execute(stmt, statementHint)

0    statementHint = statementHint or "Unknown operation"


0    if type(stmt) ~= "userdata" then
0       return false, "Invalid statement object"
     end


0    print("dbUtils.execute: Executing SQL statement")

0    if stmt then
0       local step_ok, step_err = pcall(function() stmt:step() end)
0       if not step_ok then
0          print("dbUtils.execute: SQL execution failed: " .. tostring(step_err))
0          return false, "dbUtils.execute: Failed to execute SQL statement StatementHint being: " .. tostring(step_err)
        end

0       local finalize_result = stmt:finalize()
0       if finalize_result ~= sqlite3.OK then
0          print("dbUtils.execute: SQL finalization failed: " .. DB:errmsg())
0          return false, "dbUtils.execute: Failed to finalize SQL statement StatementHint being: " .. DB:errmsg()
        end

0       print("dbUtils.execute: SQL execution successful")
0       return true, ""
     else
0       print("dbUtils.execute: Statement preparation failed: " .. DB:errmsg())
0       return false, "dbUtils.execute: Failed to prepare SQL statement StatementHint being:(" .. statementHint .. "): " .. DB:errmsg()
     end
  end

0 return dbUtils

==============================================================================
build/database.lua
==============================================================================
0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local pcall = _tl_compat and _tl_compat.pcall or pcall

0 require("globals")

0 local sqlite3 = require("lsqlite3")

0 DB = DB or sqlite3.open_memory()
0 Configured = Configured or false

0 local database = {}

  local function initializeDatabaseConnection()
0    if not DB then
0       local ok, err = pcall(function()
0          return sqlite3.open_memory()
        end)
0       if not ok then
0          print("Failed to initialize database connection: " .. tostring(err))
0          return false
        end
0       DB = err
     end
0    return true
  end

  local function executeSQL(sql)
0    local ok, err = pcall(function()
0       DB:exec(sql)
     end)
0    if not ok then
0       return false, "Failed to execute SQL: " .. tostring(err)
     end
0    return true, ""
  end

0 function database.initializeDatabase()
0    print("Initializing database")
0    if not initializeDatabaseConnection() then
0       return false
     end

0    if not Configured then
0       print("Setting up database schema")
0       local tables = {

0          [[
          CREATE TABLE IF NOT EXISTS Providers (
            provider_id TEXT PRIMARY KEY,
            stake INTEGER,
            active INTEGER,
            active_challenge_requests TEXT,
            active_output_requests TEXT,
            random_balance INTEGER,
            created_at INTEGER
          );
        ]],

0          [[
          CREATE TABLE IF NOT EXISTS Verifiers (
            process_id TEXT PRIMARY KEY,
            status TEXT NOT NULL,
            current_segment TEXT
          )
        ]],

0          [[
          CREATE TABLE IF NOT EXISTS VerifierSegments (
            segment_id TEXT PRIMARY KEY,
            proof_id TEXT NOT NULL,
            verifier_id TEXT,
            segment_data TEXT NOT NULL,
            status TEXT NOT NULL,
            timestamp INTEGER NOT NULL,
            result TEXT,
            FOREIGN KEY(verifier_id) REFERENCES Verifiers(process_id)
          )
        ]],
0          [[
          CREATE TABLE IF NOT EXISTS RandomRequests (
            request_id TEXT PRIMARY KEY,
            requester TEXT,
            callback_id TEXT,
            providers TEXT,
            requested_inputs INTEGER,
            status TEXT,
            entropy TEXT,
            created_at INTEGER
          );
        ]],
0          [[
          CREATE TABLE IF NOT EXISTS ProviderVDFResults (
            request_id TEXT,
            provider_id TEXT,
            input_value TEXT,
            modulus_value TEXT,
            output_value TEXT,
            proof TEXT,
            created_at INTEGER,
            PRIMARY KEY (request_id, provider_id),
            FOREIGN KEY (request_id) REFERENCES RandomRequests(request_id)
          );
        ]],
        }

0       for _, sql in ipairs(tables) do
0          local ok, err = executeSQL(sql)
0          if not ok then
0             print("Database initialization failed: " .. err)
0             return false
           end
        end

0       Configured = true
     end

0    print("Database initialization complete")
0    return true
  end

0 return database

==============================================================================
build/tokenManager.lua
==============================================================================
0 local tokenManager = {}

0 function tokenManager.sendTokens(token, recipient, quantity, note)
0    ao.send({
        Target = token,
        Action = "Transfer",
        Recipient = recipient,
        Quantity = quantity,
        ["X-Note"] = note or "Sending tokens from Random Process",
     })
  end

0 function tokenManager.returnTokens(msg, errMessage)
0    tokenManager.sendTokens(msg.From, msg.Sender, msg.Quantity, errMessage)
  end

0 return tokenManager

==============================================================================
build/providerManager.lua
==============================================================================
0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local os = _tl_compat and _tl_compat.os or os; local pcall = _tl_compat and _tl_compat.pcall or pcall; local table = _tl_compat and _tl_compat.table or table; require("globals")

0 local dbUtils = require("dbUtils")
0 local json = require("json")


0 Provider = {}









0 ProviderList = {}



0 RequestList = {}



0 local providerManager = {}

0 function providerManager.createProvider(userId)
0    print("entered providerManager.createProvider")

0    local timestamp = os.time()

0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    print("Preparing SQL statement for provider creation")
0    local stmt = DB:prepare([[
      INSERT OR IGNORE INTO Providers (provider_id, created_at)
      VALUES (:provider_id, :created_at);
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    print("Binding parameters for provider creation")
0    local bind_ok, bind_err = pcall(function()
0       stmt:bind_names({ provider_id = userId, created_at = timestamp })
     end)

0    if not bind_ok then
0       print("Failed to bind parameters: " .. tostring(bind_err))
0       stmt:finalize()
0       return false, "Failed to bind parameters: " .. tostring(bind_err)
     end

0    print("Executing provider creation statement")
0    local execute_ok, execute_err = dbUtils.execute(stmt, "Create provider")

0    if not execute_ok then
0       print("Provider creation failed: " .. execute_err)
     else
0       print("Provider created successfully")
     end

0    return execute_ok, execute_err
  end

0 function providerManager.getProvider(userId)
0    print("entered providerManager.getProvider")

0    local stmt = DB:prepare("SELECT * FROM Providers WHERE provider_id = :provider_id")
0    stmt:bind_names({ provider_id = userId })
0    local result = dbUtils.queryOne(stmt)

0    if result then
0       return result, ""
     else
0       return {}, "Provider not found"
     end
  end

0 function providerManager.pushActiveRequests(providerIds, requestId, challenge)
0    print("entered providerManager.pushActiveRequests")
0    local success = true
0    local err = ""

0    for _, value in ipairs(providerIds) do
0       local provider = providerManager.getProvider(value)

0       if not provider then
0          print("Provider with ID " .. value .. " not found.")
0          success = false
0          err = err .. " " .. value
0          return success, err
        end

0       if challenge == true then
           local active_challenge_requests
0          if provider.active_challenge_requests then

0             active_challenge_requests = json.decode(provider.active_challenge_requests)
           else

0             active_challenge_requests = { request_ids = {} }
           end


0          table.insert(active_challenge_requests.request_ids, requestId)


0          local stringified_requests = json.encode(active_challenge_requests)

0          local stmt = DB:prepare([[
          UPDATE Providers
          SET active_challenge_requests = :active_challenge_requests
          WHERE provider_id = :provider_id;
0       ]])
0          stmt:bind_names({ provider_id = provider.provider_id, active_challenge_requests = stringified_requests })

0          local ok = pcall(function()
0             dbUtils.execute(stmt, "Failed to update provider active challenge requests")
           end)

0          if not ok then
0             print("Failed to update provider active challenge requests for provider ID " .. provider.provider_id)
0             success = false
0             err = err .. " " .. provider.provider_id
0             return success, err
           end
        else
0          print("made here")
           local active_output_requests
0          if provider.active_output_requests then

0             active_output_requests = json.decode(provider.active_output_requests)
           else

0             active_output_requests = { request_ids = {} }
           end


0          table.insert(active_output_requests.request_ids, requestId)


0          local stringified_requests = json.encode(active_output_requests)

0          local stmt = DB:prepare([[
          UPDATE Providers
          SET active_output_requests = :active_output_requests
          WHERE provider_id = :provider_id;
0       ]])
0          stmt:bind_names({ provider_id = provider.provider_id, active_output_requests = stringified_requests })

0          local ok = pcall(function()
0             dbUtils.execute(stmt, "Failed to update provider active output requests")
           end)

0          if not ok then
0             print("Failed to update provider active output requests for provider ID " .. provider.provider_id)
0             success = false
0             err = err .. " " .. provider.provider_id
0             return success, err
           end
        end
     end
  end

0 function providerManager.removeActiveRequest(provider_id, requestId, challenge)
0    print("entered providerManager.removeActiveRequest")


0    local provider = providerManager.getProvider(provider_id)
0    if not provider then
0       print("Provider with ID " .. provider_id .. " not found.")
0       return false, "Provider not found"
     end

0    if challenge then

        local active_challenge_requests
0       if provider.active_challenge_requests then
0          active_challenge_requests = json.decode(provider.active_challenge_requests)
        else
0          active_challenge_requests = { request_ids = {} }
        end


0       for i, id in ipairs(active_challenge_requests.request_ids) do
0          if id == requestId then
0             table.remove(active_challenge_requests.request_ids, i)
              break
           end
        end


0       local stringified_requests = json.encode(active_challenge_requests)


0       local stmt = DB:prepare([[
          UPDATE Providers
          SET active_challenge_requests = :active_challenge_requests
          WHERE provider_id = :provider_id;
0     ]])
0       stmt:bind_names({ provider_id = provider_id, active_challenge_requests = stringified_requests })

0       local ok = pcall(function()
0          dbUtils.execute(stmt, "Failed to update provider active challenge requests")
        end)

0       if not ok then
0          print("Failed to update provider active challenge requests for provider ID " .. provider_id)
0          return false, "Failed to update provider active challenge requests"
        end
     else

        local active_output_requests
0       if provider.active_output_requests then
0          active_output_requests = json.decode(provider.active_output_requests)
        else
0          active_output_requests = { request_ids = {} }
        end


0       for i, id in ipairs(active_output_requests.request_ids) do
0          if id == requestId then
0             table.remove(active_output_requests.request_ids, i)
              break
           end
        end


0       local stringified_requests = json.encode(active_output_requests)


0       local stmt = DB:prepare([[
          UPDATE Providers
          SET active_output_requests = :active_output_requests
          WHERE provider_id = :provider_id;
0     ]])
0       stmt:bind_names({ provider_id = provider_id, active_output_requests = stringified_requests })

0       local ok = pcall(function()
0          dbUtils.execute(stmt, "Failed to update provider active output requests")
        end)

0       if not ok then
0          print("Failed to update provider active output requests for provider ID " .. provider_id)
0          return false, "Failed to update provider active output requests"
        end
     end

0    return true, "Request ID removed successfully"
  end

0 function providerManager.getActiveRequests(userId, challenge)
0    print("entered providerManager.getActiveRequests")
0    local provider = providerManager.getProvider(userId)
0    if challenge then
0       if provider.active_challenge_requests then
0          return provider.active_challenge_requests, ""
        else
0          return "", "No active challenge requests found"
        end
     else
0       if provider.active_output_requests then
0          return provider.active_output_requests, ""
        else
0          return "", "No active output requests found"
        end
     end
  end

0 function providerManager.hasActiveRequest(userId, requestId, challenge)
0    print("entered providerManager.hasActiveRequest")

0    local activeRequests, err = providerManager.getActiveRequests(userId, challenge)
0    if err == "" then
0       local requestIds = json.decode(activeRequests)
0       for _, request_id in ipairs(requestIds.request_ids) do
0          if request_id == requestId then
0             return true
           end
        end
0       return false
     else
0       return false
     end
  end

0 function providerManager.checkStakeStubbed(_userId)
0    print("entered providerManager.checkStakeStubbed")
0    return true, ""
  end

0 function providerManager.checkStake(userId)
0    print("entered providerManager.checkStake")

0    local provider, _ = providerManager.getProvider(userId)
0    if provider.stake < RequiredStake then
0       return false, "Stake is less than required"
     else
0       return true, ""
     end
  end

0 function providerManager.updateProviderBalance(userId, balance)
0    print("entered providerManager.updateProviderBalance")

0    local stmt = DB:prepare([[
      UPDATE Providers
      SET random_balance = :balance
      WHERE provider_id = :provider_id;
0   ]])
0    stmt:bind_names({ provider_id = userId, balance = balance })

0    local ok = pcall(function()
0       dbUtils.execute(stmt, "Failed to update provider balance")
     end)

0    if ok then
0       return true, ""
     else
0       return false, "Failed to update provider balance"
     end
  end

0 function providerManager.updateProviderStatus(userId, active)
0    print("entered providerManager.updateProviderStatus")

     local stmt
0    local status = active and 1 or 0

0    stmt = DB:prepare([[
      UPDATE Providers
      SET active = :active
      WHERE provider_id = :provider_id;
0   ]])

0    stmt:bind_names({ provider_id = userId, active = status })

0    local ok = pcall(function()
0       dbUtils.execute(stmt, "Failed to update Provider status")
     end)

0    if ok then
0       return true, ""
     else
0       return false, "Failed to update Provider status"
     end
  end

0 return providerManager

==============================================================================
build/main.lua
==============================================================================
0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local debug = _tl_compat and _tl_compat.debug or debug; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local math = _tl_compat and _tl_compat.math or math; local table = _tl_compat and _tl_compat.table or table; local xpcall = _tl_compat and _tl_compat.xpcall or xpcall
0 require("globals")
0 local json = require("json")
0 local database = require("database")
0 local providerManager = require("providerManager")
0 local randomManager = require("randomManager")
0 local tokenManager = require("tokenManager")
0 local verifierManager = require("verifierManager")


0 ResponseData = {}





0 ReplyData = {}




0 UpdateProviderRandomBalanceData = {}



0 PostVDFChallengeData = {}





0 PostVDFOutputAndProofData = {}





0 CheckpointResponseData = {}





0 GetProviderRandomBalanceData = {}



0 GetOpenRandomRequestsData = {}



0 GetRandomRequestsData = {}



0 GetRandomRequestViaCallbackIdData = {}



0 CreateRandomRequestData = {}





0 GetProviderRandomBalanceResponse = {}




0 GetOpenRandomRequestsResponse = {}





0 RandomRequestResponse = {}




0 GetRandomRequestsResponse = {}




0 database.initializeDatabase()


0 verifierManager.initializeVerifierManager()


0 function sendResponse(target, action, data)
0    return {
        Target = target,
        Action = action,
        Data = json.encode(data),
     }
  end


0 function sendReply(action, data)
0    return {
        Action = action,
        Data = json.encode(data),
     }
  end


  local function errorHandler(err)
0    print("Critical error occurred: " .. tostring(err))
0    print(debug.traceback())
  end


  local function wrapHandler(handlerFn)
     return function(msg)
0       local success = xpcall(function() return handlerFn(msg) end, errorHandler)
0       if not success then
0          if msg.Sender == nil then
0             ao.send(sendResponse(msg.From, "Error", { message = "An unexpected error occurred. Please try again later." }))
           else
0             ao.send(sendResponse(msg.Sender, "Error", { message = "An unexpected error occurred. Please try again later." }))
           end
        end
     end
  end


  local function createProvider(userid)
0    local success, _ = providerManager.createProvider(userid)
0    return success
  end


  local function infoHandler(msg)
0    ao.send(sendResponse(msg.From, "Info", {}))
  end


0 function updateProviderBalanceHandler(msg)
0    print("entered updateProviderBalance")

0    local userId = msg.From

0    createProvider(userId)

0    local staked, _ = providerManager.checkStakeStubbed(userId)

0    if not staked then
0       ao.send(sendResponse(msg.From, "Error", { message = "Update failed: Provider not staked" }))
0       return false
     end

0    local data = (json.decode(msg.Data))
0    local balance = data.availableRandomValues
0    local success, _err = providerManager.updateProviderBalance(userId, balance)

0    if success then

0       return true
     else

0       return false
     end
  end


0 function postVDFChallengeHandler(msg)
0    print("entered postVDFChallenge")

0    local userId = msg.From

0    local data = (json.decode(msg.Data))
0    local requestId = data.requestId
0    local modulus = data.modulus
0    local input = data.input

0    local requested = providerManager.hasActiveRequest(userId, requestId, true)

0    if not requested then
0       ao.send(sendResponse(msg.From, "Error", { message = "Failed to post VDF Input: " .. "not requested" }))
0       return false
     end

0    local success, _err = randomManager.postVDFChallenge(userId, requestId, input, modulus)

0    if success then
0       providerManager.removeActiveRequest(userId, requestId, true)
0       randomManager.decrementRequestedInputs(requestId)

0       return true
     else

0       return false
     end
  end


0 function postVDFOutputAndProofHandler(msg)
0    print("entered postVDFOutputAndProof")

0    local userId = msg.From

0    local data = (json.decode(msg.Data))
0    local output = data.output
0    local proof = data.proof

     local function validateInputs(_output, _proof)
0       return true
     end

0    if output == nil or proof == nil or not validateInputs(output, proof) then
0       ao.send(sendResponse(msg.From, "Error", { message = "Failed to post VDF Output: " .. "values not provided" }))
0       return false
     end

0    local requestId = data.requestId

0    local requested = providerManager.hasActiveRequest(userId, requestId, false)
0    if not requested then
0       ao.send(sendResponse(msg.From, "Error", { message = "Failed to post VDF Output: " .. "not requested" }))
0       return false
     end
0    providerManager.removeActiveRequest(userId, requestId, false)

0    local success, _err = randomManager.postVDFOutputAndProof(userId, requestId, output, proof)

0    if success then
0       randomManager.decrementRequestedInputs(requestId)

0       return true
     else


0       return false
     end
  end


0 function postVerificationHandler(msg)
0    print("entered postVerification")

0    local verifierId = msg.From

0    local data = (json.decode(msg.Data))

0    local valid = data.valid
0    local requestId = data.request_id
0    local segmentId = data.segment_id

     local function validateVerificationInputs(_valid, _requestId, _segmentId)
0       return true
     end

0    if valid == nil or segmentId == nil or requestId == nil or not validateVerificationInputs(valid, requestId, segmentId) then
0       print("Failed to post Verification: " .. "values not provided or malformed")
0       ao.send(sendResponse(msg.From, "Error", { message = "Failed to post Verification: " .. "values not provided or malformed" }))
0       return false
     end

0    local success, _err = verifierManager.processVerification(verifierId, requestId, segmentId, valid)

0    if success then
0       randomManager.decrementRequestedInputs(requestId)

0       return true
     else


0       return false
     end
  end


0 function getProviderRandomBalanceHandler(msg)
0    print("entered getProviderRandomBalance")

0    local data = (json.decode(msg.Data))
0    local providerId = data.providerId
0    local providerInfo, err = providerManager.getProvider(providerId)
0    local randomBalance = providerInfo.random_balance
0    if err == "" then
0       local responseData = { providerId = providerId, availibleRandomValues = randomBalance }
0       ao.send(sendResponse(msg.From, "Get-Providers-Random-Balance-Response", responseData))
0       return true
     else
0       ao.send(sendResponse(msg.From, "Error", { message = "Provider not found: " .. err }))
0       return false
     end
  end


0 function creditNoticeHandler(msg)
0    print("entered creditNotice")

0    local value = math.floor(tonumber(msg.Quantity))
0    local callbackId = msg.Tags["X-CallbackId"] or nil

0    if msg.From ~= TokenInUse then
0       local err = "Invalid Token Sent: " .. msg.From
0       print(err)
0       ao.send(sendResponse(msg.Sender, "Error", { message = err }))
0       tokenManager.returnTokens(msg, err)
0       return false
     end
0    if value < Cost then
0       local err = "Invalid Value Sent: " .. tostring(value)
0       print(err)
0       ao.send(sendResponse(msg.Sender, "Error", { message = err }))
0       tokenManager.returnTokens(msg, err)
0       return false
     end
0    if callbackId == nil then
0       local err = "Failure: No Callback ID provided"
0       print(err)
0       ao.send(sendResponse(msg.Sender, "Error", { message = err }))
0       tokenManager.returnTokens(msg, err)
0       return false
     end

0    local userId = msg.Sender
0    local providers = msg.Tags["X-Providers"] or nil
0    local requestedInputs = msg.Tags["X-RequestedInputs"] or ""

0    local success, err = randomManager.createRandomRequest(userId, providers, callbackId, requestedInputs)

0    if success then
0       ao.send(sendResponse(userId, "Created New Random Request", SuccessMessage))
0       return true
     else
0       ao.send(sendResponse(userId, "Error", { message = "Failed to create new random request: " .. err }))
0       return false
     end
  end


0 function getOpenRandomRequestsHandler(msg)
0    print("entered getOpenRandomRequests")

0    local data = (json.decode(msg.Data))
0    local providerId = data.providerId

0    local _, providerErr = providerManager.getProvider(providerId)

0    if providerErr ~= "" then
0       ao.send(sendResponse(msg.From, "Error", { message = "Provider not found" }))
0       return false
     end

0    local responseData = { providerId = providerId, activeChallengeRequests = { request_ids = {} }, activeOutputRequests = { request_ids = {} } }

0    local activeChallengeRequests, err = providerManager.getActiveRequests(providerId, true)
0    local activeOutputRequests, outputErr = providerManager.getActiveRequests(providerId, false)

0    if err == "" then
0       local requestIds = json.decode(activeChallengeRequests)
0       responseData.activeChallengeRequests = requestIds
     end
0    if outputErr == "" then
0       local requestIds = json.decode(activeOutputRequests)
0       responseData.activeOutputRequests = requestIds
     end

0    ao.send(sendResponse(msg.From, "Get-Open-Random-Requests-Response", responseData))
0    return true
  end


0 function getRandomRequestsHandler(msg)
0    print("entered getRandomRequests")

0    local data = (json.decode(msg.Data))
0    local responseData = { randomRequestResponses = {} }

0    for _, request_id in ipairs(data.requestIds) do
0       local requestResponse = {
           randomRequest = nil,
           providerVDFResults = nil,
        }
0       local request, requestErr = randomManager.getRandomRequest(request_id)
0       if requestErr == "" then
0          requestResponse.randomRequest = request
0          local providerVDFResults, resultsErr = randomManager.getVDFResults(request_id)
0          if resultsErr == "" then
0             requestResponse.providerVDFResults = providerVDFResults
           end
        end
0       table.insert(responseData.randomRequestResponses, requestResponse)
     end

0    ao.send(sendResponse(msg.From, "Get-Random-Requests-Response", responseData))
0    return true
  end


0 function getRandomRequestViaCallbackIdHandler(msg)
0    print("entered getRandomRequestViaCallbackId")

0    local data = (json.decode(msg.Data))
0    local callback_id = data.callbackId
0    local responseData = { randomRequestResponses = {} }

0    local requestResponse = {
        randomRequest = nil,
        providerVDFResults = nil,
     }
0    local request, requestErr = randomManager.getRandomRequestViaCallbackId(callback_id)
0    local request_id = request.request_id

0    if requestErr == "" then
0       requestResponse.randomRequest = request
0       local providerVDFResults, resultsErr = randomManager.getVDFResults(request_id)
0       if resultsErr == "" then
0          requestResponse.providerVDFResults = providerVDFResults
        end
     end
0    table.insert(responseData.randomRequestResponses, requestResponse)
0    msg.reply({ Data = json.encode(responseData) })


0    return true
  end


0 Handlers.add('info',
0 Handlers.utils.hasMatchingTag('Action', 'Info'),
0 wrapHandler(infoHandler))

0 Handlers.add('updateProviderBalance',
0 Handlers.utils.hasMatchingTag('Action', 'Update-Providers-Random-Balance'),
0 wrapHandler(updateProviderBalanceHandler))

0 Handlers.add('postVDFChallenge',
0 Handlers.utils.hasMatchingTag('Action', 'Post-VDF-Challenge'),
0 wrapHandler(postVDFChallengeHandler))

0 Handlers.add('postVDFOutputAndProof',
0 Handlers.utils.hasMatchingTag('Action', 'Post-VDF-Output-And-Proof'),
0 wrapHandler(postVDFOutputAndProofHandler))

0 Handlers.add('postVerification',
0 Handlers.utils.hasMatchingTag('Action', 'Post-Verification'),
0 wrapHandler(postVerificationHandler))

0 Handlers.add('getProviderRandomBalance',
0 Handlers.utils.hasMatchingTag('Action', 'Get-Providers-Random-Balance'),
0 wrapHandler(getProviderRandomBalanceHandler))

0 Handlers.add('creditNotice',
0 Handlers.utils.hasMatchingTag('Action', 'Credit-Notice'),
0 wrapHandler(creditNoticeHandler))

0 Handlers.add('getOpenRandomRequests',
0 Handlers.utils.hasMatchingTag('Action', 'Get-Open-Random-Requests'),
0 wrapHandler(getOpenRandomRequestsHandler))

0 Handlers.add('getRandomRequests',
0 Handlers.utils.hasMatchingTag('Action', 'Get-Random-Requests'),
0 wrapHandler(getRandomRequestsHandler))

0 Handlers.add('getRandomRequestViaCallbackId',
0 Handlers.utils.hasMatchingTag('Action', 'Get-Random-Request-Via-Callback-Id'),
0 wrapHandler(getRandomRequestViaCallbackIdHandler))


0 print("RandAO Process Initialized")

==============================================================================
build/verifierManager.lua
==============================================================================
0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local os = _tl_compat and _tl_compat.os or os; local pcall = _tl_compat and _tl_compat.pcall or pcall; local table = _tl_compat and _tl_compat.table or table
0 require("globals")
0 local dbUtils = require("dbUtils")
0 local json = require("json")


0 VerifierProcess = {}





0 VerifierSegment = {}









0 Proof = {}



0 VerifierStats = {}




0 VDFRequestData = {}








0 VDFRequestResponse = {}





0 local verifierManager = {}


0 function verifierManager.registerVerifier(processId)
0    print("Registering verifier: " .. processId)

0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      INSERT OR REPLACE INTO Verifiers
      (process_id, status)
      VALUES (:pid, 'available')
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({ pid = processId })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return false, "Failed to bind parameters"
     end

0    local exec_ok, exec_err = dbUtils.execute(stmt, "Register verifier")
0    if not exec_ok then
0       return false, exec_err
     end

0    return true, ""
  end


0 function verifierManager.getAvailableVerifiers()
0    if not DB then
0       print("Database connection not initialized")
0       return {}, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      SELECT * FROM Verifiers
      WHERE status = 'available'
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return {}, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local rows = dbUtils.queryMany(stmt)
0    local verifiers = {}

0    for _, row in ipairs(rows) do
0       local verifier = {
           process_id = tostring(row.process_id),
           status = tostring(row.status),
           current_segment = row.current_segment and tostring(row.current_segment) or "",
        }
0       table.insert(verifiers, verifier)
     end

0    return verifiers, ""
  end


0 function verifierManager.getStats()
0    local stats = {
        total_available = 0,
        total_busy = 0,
     }

0    if not DB then
0       print("Database connection not initialized")
0       return stats
     end

0    local stmt = DB:prepare([[
      SELECT
        COUNT(CASE WHEN status = 'available' THEN 1 END) as available,
        COUNT(CASE WHEN status = 'busy' THEN 1 END) as busy
      FROM Verifiers
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return stats
     end

0    local row = dbUtils.queryOne(stmt)
0    if row then
0       stats.total_available = tonumber(row.available) or 0
0       stats.total_busy = tonumber(row.busy) or 0
     end

0    return stats
  end

0 function verifierManager.requestVerification(processId, data, checkpoint)
0    print("Sending verification request to process: " .. processId)

0    if checkpoint then
0       local _ = ao.send({
           Target = processId,
           Action = "Validate-Checkpoint",
           Data = json.encode(data),
        })
0       return
     else
0       local _ = ao.send({
           Target = processId,
           Action = "Validate-Output",
           Data = json.encode(data),
        })
     end
  end


0 function verifierManager.assignSegment(verifierId, segmentId)
0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      UPDATE Verifiers
      SET status = 'busy', current_segment = :segment
      WHERE process_id = :pid AND status = 'available'
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({
           pid = verifierId,
           segment = segmentId,
        })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return false, "Failed to bind parameters"
     end

0    local exec_ok, exec_err = dbUtils.execute(stmt, "Assign segment")
0    if not exec_ok then
0       return false, exec_err
     end

0    return true, ""
  end


0 function verifierManager.markAvailable(verifierId)
0    print("Marking verifier as available: " .. verifierId)
0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      UPDATE Verifiers
      SET status = 'available', current_segment = NULL
      WHERE process_id = :pid
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({ pid = verifierId })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return false, "Failed to bind parameters"
     end

0    local exec_ok, exec_err = dbUtils.execute(stmt, "Mark verifier available")
0    if not exec_ok then
0       return false, exec_err
     end

0    return true, ""
  end


0 function verifierManager.processVerification(verifierId, requestId, segmentId, result)
0    print("Processing verification result for segment: " .. segmentId)
0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      UPDATE VerifierSegments
      SET status = 'processed', result = :result
      WHERE segment_id = :sid
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({
           sid = segmentId,
           result = result,
        })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return false, "Failed to bind parameters"
     end

0    local exec_ok, exec_err = dbUtils.execute(stmt, "Process result")
0    if not exec_ok then
0       return false, exec_err
     end

0    verifierManager.markAvailable(verifierId)

0    return true, ""
  end


0 function verifierManager.createSegment(proofId, segmentCount, segmentData)
0    if not DB then
0       print("Database connection not initialized")
0       return "", "Database connection is not initialized"
     end

0    local timestamp = os.time()
0    local segmentId = proofId .. "_" .. segmentCount

0    local stmt = DB:prepare([[
      INSERT INTO VerifierSegments
      (segment_id, proof_id, segment_data, status, timestamp)
      VALUES (:sid, :pid, :data, 'pending', :time)
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return "", "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({
           sid = segmentId,
           pid = proofId,
           data = segmentData,
           time = timestamp,
        })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return "", "Failed to bind parameters"
     end

0    local exec_ok, exec_err = dbUtils.execute(stmt, "Create segment")
0    if not exec_ok then
0       return "", exec_err
     end

0    return segmentId, ""
  end


0 function verifierManager.updateSegmentStatus(segmentId, status, result)
0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      UPDATE VerifierSegments
      SET status = :status, result = :result
      WHERE segment_id = :sid
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({
           sid = segmentId,
           status = status,
           result = result,
        })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return false, "Failed to bind parameters"
     end

0    local exec_ok, exec_err = dbUtils.execute(stmt, "Update segment status")
0    if not exec_ok then
0       return false, exec_err
     end

0    return true, ""
  end


0 function verifierManager.getProofSegments(proofId, expectedOutput)
0    if not DB then
0       print("Database connection not initialized")
0       return {}, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      SELECT * FROM VerifierSegments
      WHERE proof_id = :pid
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return {}, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({ pid = proofId })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return {}, "Failed to bind parameters"
     end

0    local rows = dbUtils.queryMany(stmt)
0    local segments = {}

0    for _, row in ipairs(rows) do
0       local segment = {
           segment_id = tostring(row.segment_id),
           proof_id = tostring(row.proof_id),
           verifier_id = row.verifier_id and tostring(row.verifier_id) or "",
           segment_data = tostring(row.segment_data),
           status = tostring(row.status),
           timestamp = tonumber(row.timestamp) or 0,
           result = row.result and tostring(row.result) or "",
        }
0       table.insert(segments, segment)
     end

0    return segments, ""
  end


0 function verifierManager.processProof(requestId, input, modulus, proofJson, providerId, modExpectedOutput)

0    local proofArray = json.decode(proofJson)
0    if not proofArray then
0       return false, "Failed to parse proof JSON"
     end


0    local proof = { proof = proofArray }

0    local proofId = requestId .. "_" .. providerId
0    local availableVerifiers = verifierManager.getAvailableVerifiers()





0    local outputSegmentId, segmentCreateErr = verifierManager.createSegment(proofId, "output", modExpectedOutput)

0    if segmentCreateErr ~= "" then
0       return false, "Failed to create segment: " .. segmentCreateErr
     end

0    local outputVerifierId = availableVerifiers[1]
0    table.remove(availableVerifiers, 1)

0    local assigned, assignErr = verifierManager.assignSegment(outputVerifierId.process_id, outputSegmentId)
0    if not assigned then
0       print("Failed to assign segment: " .. assignErr)
     else
0       local outputSegmentInput = proofArray[10]
0       local segmentExpectedOutput = modExpectedOutput

0       local requestData = {
           request_id = requestId,
           segment_id = outputSegmentId,
           input = outputSegmentInput,
           expected_output = segmentExpectedOutput,
        }

0       verifierManager.requestVerification(outputVerifierId.process_id, requestData, false)
     end



0    local segmentCount = 1
0    for _, segment in ipairs(proof.proof) do
0       print("Processing segment: " .. segment .. " count: " .. segmentCount)

0       local segmentId, createErr = verifierManager.createSegment(proofId, tostring(segmentCount), segment)
0       segmentCount = segmentCount + 1

0       if createErr ~= "" then
0          return false, "Failed to create segment: " .. createErr
        end

0       if #availableVerifiers > 0 then
0          local verifierId = availableVerifiers[1]
0          table.remove(availableVerifiers, 1)

0          local assigned, assignErr = verifierManager.assignSegment(verifierId.process_id, segmentId)
0          if not assigned then
0             print("Failed to assign segment: " .. assignErr)
           else
0             local segmentInput = input
0             local segmentExpectedOutput = proofArray[segmentCount - 1]

0             if segmentCount > 2 then
0                segmentInput = proofArray[segmentCount - 2]
              end

0             local requestData = {
                 request_id = requestId,
                 segment_id = segmentId,
                 checkpoint_input = segmentInput,
                 modulus = modulus,
                 expected_output = segmentExpectedOutput,
              }

0             verifierManager.requestVerification(verifierId.process_id, requestData, true)
           end
        else
0          print("No verifiers available for segment: " .. segmentId)
        end

     end

0    return true, ""
  end


0 function verifierManager.removeVerifier(processId)
0    print("Removing verifier: " .. processId)

0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    local stmt = DB:prepare([[
      DELETE FROM Verifiers
      WHERE process_id = :pid
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local ok = false
0    ok = pcall(function()
0       stmt:bind_names({ pid = processId })
     end)

0    if not ok then
0       print("Failed to bind parameters")
0       return false, "Failed to bind parameters"
     end

0    local exec_ok, exec_err = dbUtils.execute(stmt, "Remove verifier")
0    if not exec_ok then
0       return false, exec_err
     end

0    return true, ""
  end

0 function verifierManager.initializeVerifierManager()
0    for _, verifier in ipairs(VerifierProcesses) do
0       verifierManager.registerVerifier(verifier)
     end
0    print("Verifier manager and processes initialized")
  end

0 return verifierManager

==============================================================================
build/randomManager.lua
==============================================================================
0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local math = _tl_compat and _tl_compat.math or math; local os = _tl_compat and _tl_compat.os or os; local pcall = _tl_compat and _tl_compat.pcall or pcall; local string = _tl_compat and _tl_compat.string or string; local table = _tl_compat and _tl_compat.table or table; require("globals")
0 local json = require("json")
0 local dbUtils = require("dbUtils")
0 local providerManager = require("providerManager")
0 local verifierManager = require("verifierManager")


0 ProviderVDFResult = {}









0 RandomRequest = {}










0 RandomStatus = {}



0 ProvidersValue = {}



0 RequestedInputs = {}



0 ProviderVDFResults = {}



0 RandomResponseResponse = {}




0 local randomManager = {}

0 function randomManager.generateUUID()
0    print("entered randomManager.generateUUID")

0    local template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
0    return (string.gsub(template, '[xy]', function(c)
0       local v = (c == 'x') and math.random(0, 0xf) or math.random(8, 0xb)
0       return string.format('%x', v)
     end))
  end

0 function randomManager.getRandomProviderList(requestId)
0    print("entered randomManager.getRandomProviders")

0    local stmt = DB:prepare("SELECT providers FROM RandomRequests WHERE request_id = :request_id")
0    stmt:bind_names({ request_id = requestId })
0    local result = dbUtils.queryOne(stmt)

0    if result then
0       return json.decode(result.providers), ""
     else
0       return {}, "RandomRequest providers not found"
     end
  end

0 function randomManager.updateRandomRequestStatus(requestId, newStatus)
0    print("Entered randomManager.updateRandomRequestStatus")


0    local validStatus = false
0    for _, status in ipairs(Status) do
0       if newStatus == status then
0          validStatus = true
           break
        end
     end

0    if not validStatus then
0       return false, "Failure: Invalid status: " .. tostring(newStatus)
     end


0    local stmt = DB:prepare([[
      UPDATE RandomRequests
      SET status = :status
      WHERE request_id = :request_id;
0   ]])

0    if not stmt then
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end


0    stmt:bind_names({ status = newStatus, request_id = requestId })


0    local execute_ok, execute_err = dbUtils.execute(stmt, "Update random request status")

0    if not execute_ok then
0       return false, "Failed to update random request status: " .. tostring(execute_err)
     end

0    print("Random request status updated successfully to: " .. newStatus)
0    return true, ""
  end

0 function randomManager.getRandomRequestedInputs(requestId)
0    print("entered randomManager.getRandomRequestedInputs")

0    local stmt = DB:prepare("SELECT requested_inputs FROM RandomRequests WHERE request_id = :request_id")
0    stmt:bind_names({ request_id = requestId })
0    local result = dbUtils.queryOne(stmt)
0    if result then
0       return result.requested_inputs, ""
     else
0       return nil, "RandomRequest requested_inputs not found"
     end
  end

0 function randomManager.getRandomStatus(requestId)
0    print("entered randomManager.getRandomStatus")

0    local stmt = DB:prepare("SELECT status FROM RandomRequests WHERE request_id = :request_id")
0    stmt:bind_names({ request_id = requestId })
0    local result = dbUtils.queryOne(stmt)
0    if result then
0       return result.status, ""
     else
0       return "", "RandomRequest status not found"
     end
  end

0 function randomManager.resetRandomRequestRequestedInputs(requestId, newRequestedInputs)
0    print("Entered randomManager.resetRandomRequestRequestedInputs")


0    local stmt = DB:prepare([[
      UPDATE RandomRequests
      SET requested_inputs = :requested_inputs
      WHERE request_id = :request_id;
0   ]])
0    if not stmt then
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end


0    stmt:bind_names({ requested_inputs = newRequestedInputs, request_id = requestId })


0    local execute_ok, execute_err = dbUtils.execute(stmt, "Update random request requested inputs")

0    if not execute_ok then
0       return false, "Failed to update random request requested inputs: " .. tostring(execute_err)
     end

0    print("Random request requested inputs updated successfully to: " .. newRequestedInputs)
0    return true, ""
  end

0 function randomManager.getVDFResults(requestId)
0    print("entered randomManager.getVDFResults")

0    local stmt = DB:prepare("SELECT * FROM ProviderVDFResults WHERE request_id = :request_id")
0    stmt:bind_names({ request_id = requestId })
0    local queryResult = dbUtils.queryMany(stmt)
0    print(json.encode(queryResult))
0    print(json.encode(queryResult[1]))
0    local result = {
        requestResponses = {},
     }

0    for _, response in ipairs(queryResult) do
0       table.insert(result.requestResponses, response)
     end

0    print(json.encode(result))

0    if result then
0       return result, ""
     else
0       return {}, "RandomRequest not found"
     end
  end

0 function randomManager.getRandomRequest(requestId)
0    print("entered randomManager.getRandomRequest")

0    local stmt = DB:prepare("SELECT * FROM RandomRequests WHERE request_id = :request_id")
0    stmt:bind_names({ request_id = requestId })
0    local result = dbUtils.queryOne(stmt)
0    if result then
0       return result, ""
     else
0       return {}, "RandomRequest not found"
     end
  end


0 function randomManager.processEntropy(requestId)
0    print("entered randomManager.processEntropy")

0    local results, err = randomManager.getVDFResults(requestId)
0    if err ~= "" then
0       print("Failed to get VDF results: " .. err)
0       return "", err
     end

0    results = results


0    local mixed = tonumber(results.requestResponses[1].output_value)


0    for i = 2, #results.requestResponses do
0       local value = tonumber(results.requestResponses[i].output_value)
0       if not value then
0          print("Invalid output_value at index " .. i .. ": " .. tostring(results.requestResponses[i].output_value))
0          return "", "Invalid output_value in requestResponses"
        end

0       mixed = (mixed ~ (value >> 32) ~ (value & 0xFFFFFFFF))

0       mixed = (mixed * 0x5bd1e995 + value) % (2 ^ 31 - 1)
     end

0    local entropy = tostring(math.floor(mixed))
0    print("entropy: " .. entropy)
0    return entropy, ""
  end

0 function randomManager.simulateRandomResponse(requestId)
0    print("entered simulateRandomResponse")

0    local randomRequest, err = randomManager.getRandomRequest(requestId)

0    if err ~= "" then
0       print("Failed to get random request: " .. err)
0       return false
     end

0    local target = randomRequest.requester
0    local callbackId = randomRequest.callback_id
0    local entropy = randomManager.processEntropy(requestId)
0    local action = "Random-Response"

0    local data = {
        callbackId = callbackId,
        entropy = entropy,
     }

0    ao.send({
        Target = target,
0       Tags = {
           Action = action,
        },
        Data = data,
     })
  end

0 function randomManager.decrementRequestedInputs(requestId)
0    print("Entered randomManager.decrementRequestedInputs")

0    local requested, _ = randomManager.getRandomRequestedInputs(requestId)

0    if requested == 0 then
0       return false, "Failure: can not decrement needed below 0"
     end

0    print("Requested: " .. requested)

0    requested = requested - 1

0    local stmt = DB:prepare([[
      UPDATE RandomRequests
      SET requested_inputs = :requested_inputs
      WHERE request_id = :request_id;
0   ]])

0    if not stmt then
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end


0    stmt:bind_names({ requested_inputs = requested, request_id = requestId })


0    local execute_ok, execute_err = dbUtils.execute(stmt, "Update random request requested_inputs")

0    if not execute_ok then
0       return false, "Failed to update random request requested_inputs: " .. tostring(execute_err)
     end

0    if requested == 0 then
0       local status, err = randomManager.getRandomStatus(requestId)

0       if err == "" then

0          if status == Status[1] then
0             print("Random request finished collecting inputs")
0             local providerList = randomManager.getRandomProviderList(requestId)
0             randomManager.resetRandomRequestRequestedInputs(requestId, #providerList.provider_ids)
0             providerManager.pushActiveRequests(providerList.provider_ids, requestId, false)
0             randomManager.updateRandomRequestStatus(requestId, Status[2])

0          elseif status == Status[2] then
0             print("Random request finished collecting outputs")
0             local providerList = randomManager.getRandomProviderList(requestId)
0             local requestedValue = #providerList.provider_ids * 11
0             randomManager.resetRandomRequestRequestedInputs(requestId, requestedValue)
0             randomManager.updateRandomRequestStatus(requestId, Status[3])

0          elseif status == Status[3] then
0             print("Random request finished successfully")
0             randomManager.simulateRandomResponse(requestId)
0             randomManager.updateRandomRequestStatus(requestId, Status[5])
           end
        else
0          return false, err
        end
     end

0    print("Random request requested_inputs updated successfully to: " .. requested)
0    return true, ""
  end

0 function randomManager.getRandomRequestViaCallbackId(callbackId)
0    print("entered randomManager.getRandomRequestViaCallbackId")

0    local stmt = DB:prepare("SELECT * FROM RandomRequests WHERE callback_id = :callback_id")
0    stmt:bind_names({ callback_id = callbackId })
0    local result = dbUtils.queryOne(stmt)
0    if result then
0       return result, ""
     else
0       return {}, "RandomRequest not found"
     end
  end

0 function randomManager.getVDFResult(requestId, providerId)
0    print("entered randomManager.getVDFResult")

0    local stmt = DB:prepare("SELECT * FROM ProviderVDFResults WHERE request_id = :request_id AND provider_id = :provider_id")
0    stmt:bind_names({ request_id = requestId, provider_id = providerId })
0    local result = dbUtils.queryOne(stmt)
0    if result then
0       return result, ""
     else
0       return {}, "RandomRequest not found"
     end
  end

0 function randomManager.createRandomRequest(userId, providers, callbackId, requestedInputs)
0    print("entered randomManager.createRandomRequest")

0    local timestamp = os.time()
0    local requestId = randomManager.generateUUID()


0    local providerList = json.decode(providers)
0    if not providerList or not providerList.provider_ids or #providerList.provider_ids == 0 then
0       return false, "Invalid providers list"
     end

0    local decodedRequestList = {}

0    if requestedInputs ~= "" then

0       local result = json.decode(requestedInputs)

0       if result and type(result) == "table" then
0          decodedRequestList = result
        else
0          print("Failed to decode requestedInputs. Invalid JSON or structure.")
0          return false, "Invalid requestedInputs JSON"
        end
     else

0       decodedRequestList = {}
     end


0    local requestedValue = math.min(decodedRequestList.requested_inputs or #providerList.provider_ids, #providerList.provider_ids)

0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    providerManager.pushActiveRequests(providerList.provider_ids, requestId, true)

0    print("Preparing SQL statement for random request creation")
0    local stmt = DB:prepare([[
      INSERT OR IGNORE INTO RandomRequests (request_id, requester, callback_id, providers, requested_inputs, status, created_at)
      VALUES (:request_id, :requester, :callback_id, :providers, :requested_inputs, :status, :created_at);
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    local status = Status[1]

0    print("Binding parameters for random request creation")
0    local bind_ok, bind_err = pcall(function()
0       stmt:bind_names({ request_id = requestId, requester = userId, callback_id = callbackId, providers = providers, requested_inputs = requestedValue, status = status, created_at = timestamp })
     end)

0    if not bind_ok then
0       print("Failed to bind parameters: " .. tostring(bind_err))
0       stmt:finalize()
0       return false, "Failed to bind parameters: " .. tostring(bind_err)
     end

0    print("Executing random request creation statement")
0    local execute_ok, execute_err = dbUtils.execute(stmt, "Create random request")

0    if not execute_ok then
0       print("Random Request creation failed: " .. execute_err)
     else
0       print("Random Request created successfully")
0       print("New RequestId: " .. requestId)
     end

0    return execute_ok, execute_err
  end

0 function randomManager.postVDFChallenge(userId, requestId, inputValue, modulusValue)
0    print("entered randomManager.postVDFChallenge")

0    local timestamp = os.time()

0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    print("Preparing SQL statement for provider request response creation")
0    local stmt = DB:prepare([[
      INSERT OR IGNORE INTO ProviderVDFResults (request_id, provider_id, input_value, modulus_value, created_at)
      VALUES (:request_id, :provider_id, :input_value, :modulus_value, :created_at);
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    print("Binding parameters for provider request response creation")
0    local bind_ok, bind_err = pcall(function()
0       stmt:bind_names({ request_id = requestId, provider_id = userId, input_value = inputValue, modulus_value = modulusValue, created_at = timestamp })
     end)

0    if not bind_ok then
0       print("Failed to bind parameters: " .. tostring(bind_err))
0       stmt:finalize()
0       return false, "Failed to bind parameters: " .. tostring(bind_err)
     end

0    print("Executing provider request response creation statement")
0    local execute_ok, execute_err = dbUtils.execute(stmt, "Create provider request response")

0    if not execute_ok then
0       print("Provider Request Response creation failed: " .. execute_err)
     else
0       print("Provider Request Response created successfully")
     end

0    return execute_ok, execute_err
  end

0 function randomManager.postVDFOutputAndProof(userId, requestId, outputValue, proof)
0    print("entered randomManager.postVDFOutputAndProof")

0    if not DB then
0       print("Database connection not initialized")
0       return false, "Database connection is not initialized"
     end

0    print("Preparing SQL statement for provider request response creation")
0    local stmt = DB:prepare([[
      UPDATE ProviderVDFResults
      SET output_value = :output_value, proof = :proof
      WHERE request_id = :request_id AND provider_id = :provider_id;
0   ]])

0    if not stmt then
0       print("Failed to prepare statement: " .. DB:errmsg())
0       return false, "Failed to prepare statement: " .. DB:errmsg()
     end

0    print("Binding parameters for provider request response creation")
0    local bind_ok, bind_err = pcall(function()
0       stmt:bind_names({ request_id = requestId, provider_id = userId, output_value = outputValue, proof = proof })
     end)

0    if not bind_ok then
0       print("Failed to bind parameters: " .. tostring(bind_err))
0       stmt:finalize()
0       return false, "Failed to bind parameters: " .. tostring(bind_err)
     end

0    print("Executing post vdf output and proof statement")
0    local execute_ok, execute_err = dbUtils.execute(stmt, "Post vdf output and proof")

0    if not execute_ok then
0       print("Post VDF Output and Proof failed: " .. execute_err)
     else
0       print("VDF Output and Proof posted successfully")


0       local vdfRequest = randomManager.getVDFResult(requestId, userId)
0       local input = vdfRequest.input_value
0       local modulus = vdfRequest.modulus_value


0       local processResult, processError = verifierManager.processProof(requestId, input, modulus, proof, userId, outputValue)
0       if not processResult then
0          print("Processing proof failed: " .. tostring(processError))
        else
0          print("Proof processed successfully")
        end

     end

0    return execute_ok, execute_err
  end

0 return randomManager

==============================================================================
build/globals.lua
==============================================================================
0 require("lsqlite3")





0 Admin = "KLzn6IzhmML7M-XXFNSI29GVNd3xSHtH26zuKa1TWn8"



0 RequiredStake = 10
0 Cost = 100

0 TokenTest = "OeX1V1xSabUzUtNykWgu9GEaXqacBZawtK12_q5gXaA"
0 WrappedAR = "xU9zFkq3X2ZQ6olwNVvr1vUWIjc3kXTWr7xKQD6dh10"
0 TokenInUse = TokenTest

0 SuccessMessage = "200: Success"

0 Status = {
     "COLLECTING CHALLENGES",
     "COLLECTING OUTPUTS",
     "VERIFYING OUTPUTS",
     "CRACKING",
     "FINALIZED",
     "FAILED",
  }

0 VerifierProcesses = {
     "9xtciDYCCN76fXIq1cKosh3XNzG_Qj1D3Z5XK1g5nOE",
     "RG6r_xD_NZtbw7t2QcfrUXjrlZe3w3a9vK_Z4kTrZyc",
     "aDKAxaGZSMh120sVO-XMHc2oNxpl4Zst_KaC_YB3AK0",
     "bHNe_KSStb-pmhttS6x9B2QTZ8s_duspz-r3Fz89HmI",
     "hE4pw01XluNHiUfZONVCPEQJvy7A83FzR5GJgylJ2jE",
     "aIiqaop1mZ9XuIPLd_1xVDjkQ-_wEG0L3xCB1pwf6Zg",
     "1musHHlIsIqWL-v8zuLQCclWNOH0xEtM5Bop9npHIZ0",
     "E-hoJqDj2GB6J-oveM4B5J5c6WLFQ9f9P9MeVB7ZfRs",
     "bQbqmx4ju8QHIUsTTWRXbA8VD_LxZqhxHm79dE0xqB8",
     "1Rk_Nf0ohtQ8CcD31OYDYJv4pstJFJWhU5TOMdBgWNU",
     "Ca_j7Jcx9GtCZnGnhvSHKZQZiMdOOSyYlC5g74sofAM",
     "cjTEdlZPE2By_mVk6TYRotUIrGN5jZUom6mLsFFK7ZI",
     "HdwaaNv84kWolAAxxFcq-fj6GxchSojnSamYBfAdOlw",
     "m9YnpeUM7d0FMS647VFZKqwcq6yN6NDU_7388ZDIWgk",
     "5JLl8vaqbNJK-3Z9snnOx7cDciGR43nCKcm2X1g8LQs",
     "QrDVen99sF88EvE_vffdpHzMWRP5weVzH84gXfKct3Y",
     "sREsSXZC8UdLfBiic5Nsbl16gsdooRssbdZqtHR47xk",
     "LMli3AiUXlCZcr8lSacqqrqTiTQpuMQS1TFuFSYyYCc",
     "eme9ov7v6uvLOQ9xs7TPVw31liudHbjpmoSsJrb9yKM",
     "emiZ11GY1FLPItxbgDBtuDuZFwosSKydxdX2Y3X3syU",
     "3-TUgiU4CYXybgL7X2TCGAdGkGlFQgmJh63w9ah54p8",
     "6zdG4WZnHFq0iFrqt8if0VJjLD0uMTpwI3PKE2ebMuE",
     "f8DRxguG-ebm8qkeW87TfqQPfpjDx1zFawFLqdyVqEE",
     "-3FR3L_y41ChqUg9f3LzOOjCeEYqxZnxOPBSVJvhc4g",
     "7MyjbWK2ui4YCZvI4pAei632cTYZpkPyRsYSMpqVSjk",
     "o3F_-U5FD69JHSxZJcLU8CZnM6A0lJVaJEjb3tdpyHw",
     "ocTw1Q0119A6b25W9xPNpLP2whkeTkn2AvM_1vr6dwg",
     "5uckHZGTWwxJU7MfuBTrPwe6awdqpKxV0O-L6_kmuM0",
     "KYonYg0dcgjIZHur58aq1l_Xd6FV2995C9M7IKx9ToY",
     "pCO8DCinMo2iBEYSxnpzMsQsVICnM9I3iFpHvJhiquU",
     "Zg7NsaOfedtTYZwu6HyCjpfiAMDJU2L-5zube7Pnnoc",
     "RwPOZCTE2N9GkztErOqgVWcPOQCvbkMtv6-OxIqtb3Y",
     "tNpWqM0aGL6-6CSpHb2Wrw4jCH3irwrsrpubpK9c_jg",
     "liUYPzYtFcSmtZw-kixB5fYWAAIwqoeiYcy3LqI0r5g",
     "mFSAyqgeAqph4uPNAbONTvxrYR-5-BFGpvSzbl89rEM",
     "VZjKTKen3yCRwS3fhlzb8gy040-o6cB4nc4WuzMhO_0",
     "jb5PbvwDOPvv2VQJhDBaRapsS7Hg0_nbgklRqy4NCRo",
     "MdOSjRFFPXVPZ1QuFc24aS2iH6LPBMMVtz0Hfou_YTY",
     "7lUE6vTtYzz9DX7Vel0PiVr9Gt7WXsraBfGbzsb-J0o",
     "Ad5zPlVDcyO8A_gZuCZafRG-hloEG4GEiuM3i5q_7ew",
     "0UHuoupRYAWi2ES727gWXxiB6NywyY5uSXv5pPQmWF4",
     "5zkXkGJxhXiBeHj8rFV7pMexegQYYurqR7iXuK_OeTA",
     "6NcC5lNFwyrZTyXEZ_BUpED8tlz-ml3UDVEnpsqn7NQ",
     "-B2h9yKLQ6Gmz53K2Y0B7I-maT6n3LyuX86nxp0caak",
     "ieFMM-zqmQpGrVmnFgsyqM865GS1-A5R37krMZ2PahI",
     "jrZ5KxMErZL_2aet5OVdYQZH1iyFn4MYoZ3qDeRADb0",
     "vjoC1Vu46Kz_MXcEOQJM6tuSgkpdnJZoVCjJv8_15w8",
     "YhQ9OPQQnjQXumInOLad4jp73Rv6OEEcE6FIjLnIs_g",
     "8n5FmNyOXz_y5WtROyaNdlKYjCmPN5Xz0nYlYu4HRKs",
     "GlPXlvwNgnu1wmYgDdSxX9pRCAlVUU-FeHznW5pFAX4",
     "6fzr6mfZMyY7J0gn5k2Lx-YzZpuJRDVVIIQ30eqvxIw",
     "XMjyw1B5ovTM1vuzWFiivD9C7HvTv-fzanl2ygpanRU",
     "1BaATgamA1HmAhAIaN6QzoXpjxNhNmSv41ZzQzVwlE4",
     "oIhKTSdl953AAly5HqnVnjlqdIkAMj5FxaG5QCMZ5OY",
     "8psb-hqCnQQpHPUVo7FASXA05f6GModOEryfBwR7jpc",
     "BfC87x5k19oU0dpCyoRQWrsjXhtM-1xzqLebQdki1JA",
     "HgY9erwSLwyUpXm3N6DhhSxbIzJ3XjFTqNJDVg9WJTY",
     "Bs5eEY7k5tDxO57l1SxgeWUx502-oLzegJIq5-eMz0Q",
     "3bu5EGUaF1RyR8_B28r_m2R4kpCytXWNikDQ4qDrPQM",
     "PjSK3CiGVn6iAGO5WCLIiLsrUabTXtXl6eyDFtUDrPU",
     "A5x89r00o1K_EEcYJhLTwfSmNHcU04KpslFE2GZUNEM",
     "0McQMqhI_G8F2S5R1oh5g4S4sGWxkMcD2MaVa5ELUAM",
     "iMMa2HbP-FQwiTdoK7W4GVHKD543KB221P6HAkfIKP0",
     "8gJT4MviAqdthfUjjXWrL9WDIO1zhwKNdF1HHjlsWGw",
     "JRt6hoW9blsADCdJbY8ThqJirDrj3SLSqM4CrUd1bh0",
     "mVbZzo75noxadsLdqUq64GE2fMBDvS6MB29gDnK2V4c",
     "0auksaSe4yV5Snv3MzLcJegJh7GyxXMYXP6ncjyfOfk",
     "am7uRfcD71c9ynlSXHjQZonPj8mRyp2Hz_PmzHLQ60Y",
     "NQcOoJM8m5-nxTXcJnuAeZW3PP1pT3vfi0FU9Vh5yTY",
     "k5PGnF9aoVZd26mo4e2W_6uZKl_ETATFZ4dzu9-NA-w",
     "c_0ye66-HsNRp0Dqmw4wga_XcYkK7YFIiiaPGeMY1uQ",
     "pOM79mJ6_6_2m5oLSMqFTKMC-eWUub8NU1MBgyluHA8",
     "ZC2FgZe2QPgKD4-C5120ISgull4zaJXSxz0wZqITLss",
     "gwCxgBfhdGu3gxYuuUl3pk_KVQF0V3ACpWPH2W0piLE",
     "4eVREWXvmKAMJ4RMiq9nhKbO93Sodme9a5MnMa_ObYs",
     "WyXBXMLGYpNcRhvrHrshjhFoV4PvTi1Gjj-CJh7zqto",
     "347w4pv7GnEI_0ZiqmXtl3lC3bXIBh-rhKwl1zuB0BM",
     "ccZiKD1yn8_bBHo69GVp8KOygbGh_tEn8lJHs6PGOzc",
     "0v9AAs9fhDkJyjYG7M0rViBOLlJ_DmJA-81MV7LSNnA",
     "EPocFs8XlXJhSNtcRTAjfkAUeWLG41tkSWFwK35iNfk",
     "EdvD-KQjeWtMzjW_atVR22jWJBCyNKv5ajolm0PYBj0",
     "n-CRbJNzKejlnqLNnse4aDzx4lKe0nAwcx1FrvY4pnI",
     "j2d4SznuLaSegIpN3_u85v9adVAL8NM2IrZFjjTty5k",
     "NUs5IVOr5KjydjjqLkkA6pstAgmtcPxJWknGRfA9JeY",
     "Dy45_39YaFd965jVbo57JiG-zbX9O6MpPqH5h6J9-ss",
     "1aF5qXxLA9bXihNZOmi_Gr9axwYdX8ZxIqjYTZpYITQ",
     "BEpOW5X2CPTlaKeE4NdKxzcN9Xjisic5Rmo5YebwZb8",
     "bLEW4XGsGo5IBXvXE2G5-Ai9GjymrHl5gWKwoUXyD1c",
     "4iYpSip0GqQ8Xekz-OdUf4n3AqFRwyyGEySeIcOapiw",
     "xh0satyfKYauDygZXCGwYlshCcEiec2vgYAAZvlC2aA",
     "FQ3XFhjwm7DT156S2MEi_wakF9s1n6LYPv2J8f-Ay1E",
     "HcCyWiR5eB-qAZclP_-aB5dsujK-TUHWU___Bkx5uAk",
     "zq_JQLzR2fVaw_PWxmA2WD0hJX7QFJgz3TF1XTJ5JQk",
     "kN6avGRarPdvCWMUDi5R7XFEnpRXdOy2FCv1QWkZtRc",
     "C1CElYtiNFeXaJ3YoGMNPTUv_NxJaF197F31qSHrmDI",
     "YLzRgccaT2XrRpeSrVkSJ--DGDCaW7ngkOTtVVQcG5o",
     "cjusi39QOnOdXinkJi3vcvWb8EDvNhs2qRL-M0Do9OA",
     "G6bjwtb3GIksAyF4N2zIJLcpDcXpsl3Icx2McOgoxEE",
     "H5wGgdYLz2RNtH4oAOe8ssBpABI5a5Dz2phktms6Hyk",
  }

0 return {}

==============================================================================
test/setup.lua
==============================================================================
0 local originalRequire = require

  local function mockedRequire(moduleName)
*   if moduleName == "ao" then
*     return originalRequire("test.mocked-env.ao.ao")
    end

*   if moduleName == "handlers-utils" then
*     return originalRequire("test.mocked-env.ao.handlers-utils")
    end

*   if moduleName == "handlers" then
*     return originalRequire("test.mocked-env.ao.handlers")
    end

*   if moduleName == "verifier" then
*     return originalRequire("test.mocked-env.processes.verifier")
    end

*   if moduleName == ".bint" then
0     return originalRequire("test.mocked-env.lib.bint")
    end

*   if moduleName == ".utils" then
*     return originalRequire("test.mocked-env.lib.utils")
    end

*   if moduleName == "json" then
*     return originalRequire("test.mocked-env.lib.json")
    end

*   if moduleName == "lsqlite3" then
0     return originalRequire("lsqlite3complete")
    end

*   return originalRequire(moduleName)
  end

  return function()
    -- Override the require function globally for the tests
0   _G.require = mockedRequire

    -- -- Restore the original require function after all tests
    -- teardown(function()
    --   _G.require = originalRequire
    -- end)
  end

==============================================================================
test/process_test.lua
==============================================================================
  ---@diagnostic disable: duplicate-set-field
0 require("test.setup")()
0 require("luacov")
  -- local luacov = require"luacov.runner"

  -- luacov.init() -- Resets the coverage data


* _G.VerboseTests = 0                    -- how much logging to see (0 - none at all, 1 - important ones, 2 - everything)
* _G.VirtualTime = _G.VirtualTime or nil -- use for time travel
  -- optional logging function that allows for different verbosity levels
* _G.printVerb = function(level)
0   level = level or 2
    return function(...) -- define here as global so we can use it in application code too
0     if _G.VerboseTests >= level then print(table.unpack({ ... })) end
    end
  end

* _G.IsInUnitTest = true
* _G.Owner = '123MyOwner321'
* _G.MainProcessId = '123xyzMySelfabc321'

* _G.Verifiers = {
*   "RtkXacFBEGXhw6OTjCqECKSap_y2CJMukBsGxElCd-E",
*   "qbCteSj7907pwb_SQ1AD2kMG_HZDuUVf2IZnnm4pJxc",
*   "toqzmcIxYC2yUQWJJVbd-ecBbCB2w1r_7Gvoq99DOzM",
*   "G0JLVocfhW_1qHnX64yuaVBCWdpBRhSQ3T8AkGoiIJA",
*   "Fpb42AKYswyM8nIAb6vZYBePwPUxzZhQhu72srZr1xY",
*   "06IG1T_JXyhVV0TZ42_EEDKZ7T0kBfmdDjATTaBr8ic",
*   "xcLnD6OdSbbO4dY_HAwNHLWRuNEPSJXoi4gRreywwi8",
*   "bKQiEWkOg77FqygZ4yIp7lBV5mlMDQDg3_5CS36PUqg",
*   "SqdPCK1LrMa_6-xf4a9UKchAqL26Mbj_Pg5kLk4NWxo",
    "tgfpewpX3j7htX03Cj5pCz_CB0nOzDFlc0WJi1sRxRI"
* }

* _G.Processes = {
*   [_G.Verifiers[1]] = require "verifier" (_G.Verifiers[1]),
*   [_G.Verifiers[2]] = require "verifier" (_G.Verifiers[2]),
*   [_G.Verifiers[3]] = require "verifier" (_G.Verifiers[3]),
*   [_G.Verifiers[4]] = require "verifier" (_G.Verifiers[4]),
*   [_G.Verifiers[5]] = require "verifier" (_G.Verifiers[5]),
*   [_G.Verifiers[6]] = require "verifier" (_G.Verifiers[6]),
*   [_G.Verifiers[7]] = require "verifier" (_G.Verifiers[7]),
*   [_G.Verifiers[8]] = require "verifier" (_G.Verifiers[8]),
*   [_G.Verifiers[9]] = require "verifier" (_G.Verifiers[9]),
*   [_G.Verifiers[10]] = require "verifier" (_G.Verifiers[10]),
* }

* _G.Handlers = require "handlers"

* _G.ao = require "ao" (_G.MainProcessId) -- make global so that the main process and its non-mocked modules can use it
  -- => every ao.send({}) in this test file effectively appears as if the message comes the main process

* _G.ao.env = {
*   Process = {
*     Tags = {
*       ["Name"] = "RandProcess",
        -- ... add other tags that would be passed in when the process is spawned
*     }
*   }
* }

* local process = require "process" -- require so that process handlers are loaded
0 local json = require "json"
0 local database = require "database"
0 local providerManager = require "providerManager"
0 local randomManager = require "randomManager"
  -- local utils = require "utils"
  -- local bint = require ".bint" (512)


  local resetGlobals = function()
    -- according to initialization in process.lua
0   _G.DB = nil
0   _G.Configured = nil
  end


0 describe("updateProviderBalance & getProviderRandomBalance", function()
0   setup(function()
    end)

0   teardown(function()
    end)

0   it("db should not be nil but stood up", function()
0     assert.is_not_nil(_G.DB)
    end)

0   it("configured should be true", function()
0     assert.are.equal(_G.Configured, true)
    end)

0   it("should not have a provider who has not updated balance", function()
0     ao.send({ Target = ao.id, From = "Provider1", Action = "Get-Providers-Random-Balance", Data = json.encode({providerId = "Provider1"}) })
0     local _, err = providerManager.getProvider(ao.id)
0     assert.are.equal(err, "Provider not found")
    end)

0   it("should have a provider after updated balance", function()
0     local availableRandomValues = 7
0     local message = { Target = ao.id, From = "Provider1", Action = "Update-Providers-Random-Balance", Data = json.encode({availableRandomValues = availableRandomValues}) }
0     local success = updateProviderBalanceHandler(message)
0     assert(success, "Failure: failed to update")
0     local _, err = providerManager.getProvider("Provider1")
0     assert.are_not.equal(err, "Provider not found")
    end)


0   it("should have a provider after updated balance for second instantiated provider", function()
0     local availableRandomValues = 11
0     local message = { Target = ao.id, From = "Provider3", Action = "Update-Providers-Random-Balance", Data = json.encode({availableRandomValues = availableRandomValues}) }
0     local success = updateProviderBalanceHandler(message)
0     assert(success, "Failure: failed to update")
0     local _, err = providerManager.getProvider("Provider3")
0     assert.are_not.equal(err, "Provider not found")
    end)

0   it("should update the provider balance after update", function()
0     local availableRandomValues = 10
0     local message = { Target = ao.id, From = "Provider1", Action = "Update-Providers-Random-Balance", Data = json.encode({availableRandomValues = availableRandomValues}) }
0     local success = updateProviderBalanceHandler(message)
0     assert(success, "Failure: failed to update")
      -- Retrieve the provider and check for errors
0     local provider, _ = providerManager.getProvider("Provider1")
      -- Now, try to access and assert the value
0     assert.are.equal(10, provider.random_balance)
    end)

0   it("should not be able to retrieve unupdated balance", function()
0     local providerId = "Provider2"
0     local message = { Target = ao.id, From = "Provider2", Action = "Get-Providers-Random-Balance", Data = json.encode({providerId = providerId}) }
0     local success = getProviderRandomBalanceHandler(message)
0     assert(not success, "Failure: Able to query unset balance with handler")
    end)

0   it("should be able to retrieve updated balance", function()
0     local providerId = "Provider1"
0     local message = { Target = ao.id, From = "Provider1", Action = "Get-Providers-Random-Balance", Data = json.encode({providerId = providerId}) }
0     local success = getProviderRandomBalanceHandler(message)
0     assert(success, "Failure: Unable to query set balance with handler")
    end)
  end)

0 describe("requestRandom", function()
0   setup(function()
      -- to execute before this describe
    end)

0   teardown(function()
    end)

0   it("should not be able to request random from a registered provider with insufficient quantity and correct token", function()
0     local userId = "Requester1"
0     local providers = json.encode({provider_ids = {"Provider1"}})
0     local callbackId = "xxxx-xxxx-4xxx-xxxx"

0     local message = {
        Target = ao.id,
        From = TokenInUse,
        Action = "Credit-Notice",
        Quantity = "99",
0       Tags = {
          ["X-Providers"] = providers,
          ["X-CallbackId"] = callbackId,
0         Sender = userId
        }
      }
0     local success = creditNoticeHandler(message)
0     assert(not success, "Failure: able to create random request with insufficient quantity")
    end)

0   it("should not be able to request random from a registered provider with sufficient quantity but incorrect token", function()
0     local userId = "Requester1"
0     local providers = json.encode({provider_ids = {"Provider1"}})
0     local callbackId = "xxxx-xxxx-4xxx-xxxx"

0     local message = {
        Target = ao.id,
        From = "Not the token in use",
        Action = "Credit-Notice",
        Quantity = "100",
0       Tags = {
          ["X-Providers"] = providers,
          ["X-CallbackId"] = callbackId,
          Sender = userId,
        }
      }
0     local success = creditNoticeHandler(message)
0     assert(not success, "Failure: able to create random request with incorrect token")
    end)

0   it("should not be able to request random from a registered provider with sufficient quantity correct token but no callback id", function()
0     local userId = "Requester1"
0     local providers = json.encode({provider_ids = {"Provider1"}})

0     local message = {
        Target = ao.id,
        From = TokenInUse,
        Action = "Credit-Notice",
        Quantity = "100",
0       Tags = {
          ["X-Providers"] = providers,
          Sender = userId,
        }
      }
0     local success = creditNoticeHandler(message)
0     assert(not success, "Failure: able to create random request with no callback id")
    end)

0   it("should be able to request random from a registered provider with correct balance and correct requested inputs and token", function()
0     local userId = "Requester1"
0     local providers = json.encode({provider_ids = {"Provider1", "Provider3"}})
0     local callbackId = "xxxx-xxxx-4xxx-xxxx"
0     local requested_inputs = json.encode({requested_inputs = 1})
0     local message = {
        Target = ao.id,
        From = TokenInUse,
        Action = "Credit-Notice",
        Quantity = "100",
0       Tags = {
          ["X-Providers"] = providers,
          ["X-CallbackId"] = callbackId,
          ["X-RequestedInputs"] = requestedInputs,
0         Sender = userId
        }
      }
0     local success = creditNoticeHandler(message)

0     assert(success, "Failure: failed to create random request")
    end)

0   it("should not be able to request random from no providers with correct balance and token", function()
0     local userId = "Requester1"
0     local providers = json.encode({provider_ids = {}})
0     local callbackId = "xxxx-xxxx-4xxx-xxxx"

0     local message = {
        Target = ao.id,
        From = TokenInUse,
        Action = "Credit-Notice",
        Quantity = "100",
0       Tags = {
          ["X-Providers"] = providers,
          ["X-CallbackId"] = callbackId,
0         Sender = userId
        }
      }
0     local success = creditNoticeHandler(message)

0     assert(not success, "Failure: able to create random request with no providers")
    end)

0   it("should be able to see random status",
    function ()
0     local status, err = randomManager.getRandomStatus("d6cce35c-487a-458f-bab2-9032c2621f38")
0     assert(err == "", "Failure: no status found")
    end)
    
0   it("should not be able to see updated active_requests for an unrequested provider",
    function ()
0     local _, err = providerManager.getActiveRequests("Provider2", true)
0     assert(err == "No active challenge requests found", "Failure: active request found")
    end)

0   it("should be able to see updated active_requests for our requested provider",
    function ()
0     local _, err = providerManager.getActiveRequests("Provider1", true)
0     assert(err == "", "Failure: no active request found")
0     local _, error = providerManager.getActiveRequests("Provider3", true)
0     assert(error == "", "Failure: no active request found")
    end)

0   it("should not be able to retrieve active_requests for an unrequested provider",
    function ()
0     local providerId = "Provider2"
0     local message = {
        Target = ao.id,
        From = "Provider2",
        Action = "Get-Open-Random-Requests",
0       Data = json.encode({providerId = providerId})
      }
0     local success = getOpenRandomRequestsHandler(message)
0     assert(not success, "Failure: able to get active requests from an unrequested provider")
0     local _, err = providerManager.getActiveRequests("Provider2", true)
0     assert(err == "No active challenge requests found", "Failure: active request found")
    end)

0   it("should be able to retrieve active_requests for our requested provider",
    function ()
0     local providerId = "Provider1"
0     local message = {
        Target = ao.id,
        From = "Provider1",
        Action = "Get-Open-Random-Requests",
0       Data = json.encode({providerId = providerId})
      }
0     local success = getOpenRandomRequestsHandler(message)
0     assert(success, "Failure: unable to get active requests from a requested provider")

0     local _, err = providerManager.getActiveRequests("Provider1", true)
0     assert(err == "", "Failure: no active request found")
    end)

0   it("should be able to retrieve active_requests for our second requested provider",
    function ()
0     local providerId = "Provider3"
0     local message = {
        Target = ao.id,
        From = "Provider3",
        Action = "Get-Open-Random-Requests",
0       Data = json.encode({providerId = providerId})
      }
0     local success = getOpenRandomRequestsHandler(message)
0     assert(success, "Failure: unable to get active requests from a requested provider")

0     local _, err = providerManager.getActiveRequests("Provider3", true)
0     assert(err == "", "Failure: no active request found")
    end)
  end)

0 describe("postVDFChallenge", function()
0   setup(function()
      -- to execute before this describe
    end)

0   teardown(function()
    end)

0   it("should not be able to post challenge from an unrequested provider for a valid request",
    function()
0     local input = "0x023456987678"
0     local modulus = "0x0567892345678"
0     local requestId = "d6cce35c-487a-458f-bab2-9032c2621f38"

0     local message = {
        Target = ao.id,
        From = "Provider2",
        Action = "Post-VDF-Challenge",
0       Data = json.encode({input = input, modulus = modulus, requestId = requestId})
      }

0     local success = postVDFChallengeHandler(message)
      
0     assert(not success, "Failure: able to post VDF Challenge from unrequested provider")
    end)

0   it("should not be able to post challenge from an unrequested provider for an invalid request",
    function()
0     local input = "0x023456987678"
0     local modulus = "0x0567892345678"
0     local requestId = "a6cce35c-487a-458f-bab2-9032c2621f38"

0     local message = {
        Target = ao.id,
        From = "Provider2",
        Action = "Post-VDF-Challenge",
0       Data = json.encode({input = input, modulus = modulus, requestId = requestId})
      }

0     local success = postVDFChallengeHandler(message)
0     assert(not success, "Failure: able to post VDF Challenge from unrequested provider")
    end)

0   it("should be able to post challenge from a requested provider for a valid request",
    function()
0     local input = "0x023456987678"
0     local modulus = "0x0567892345678"
0     local requestId = "d6cce35c-487a-458f-bab2-9032c2621f38"

0     local message = {
        Target = ao.id,
        From = "Provider1",
        Action = "Post-VDF-Challenge",
0       Data = json.encode({input = input, modulus = modulus, requestId = requestId})
      }

0     local success = postVDFChallengeHandler(message)
0     assert(success, "Failure: unable to post VDF Challenge from requested provider")
    end)

0   it("should not be able to post output and proof from a requested provider for a valid request before all challenges are posted",
    function()
0     local output = "0x023456987678"
0     local proof = json.encode({"0x0567892345678", "fghjkl", "0x0567892345678", "fghjkl", "0x0567892345678", "0x0567892345678", "fghjkl", "0x0567892345678", "fghjkl", "0x0567892345678" })
0     local requestId = "d6cce35c-487a-458f-bab2-9032c2621f38"

0     local message = {
        Target = ao.id,
        From = "Provider1",
        Action = "Post-VDF-Output-And-Proof",
0       Data = json.encode({output = output, proof = proof, requestId = requestId})
      }

0     local success = postVDFOutputAndProofHandler(message)
0     assert(not success, "Failure: able to post VDF output and proof from requested provider vefore all challenges are posted")
    end)
    
0   it("should be able to post challenge from second requested provider for a valid request",
    function()
0     local input = "0x023456987678"
0     local modulus = "0x0567892345678"
0     local requestId = "d6cce35c-487a-458f-bab2-9032c2621f38"

0     local message = {
        Target = ao.id,
        From = "Provider3",
        Action = "Post-VDF-Challenge",
0       Data = json.encode({input = input, modulus = modulus, requestId = requestId})
      }

0     local success = postVDFChallengeHandler(message)
0     assert(success, "Failure: unable to post VDF Challenge from requested provider")
    end)

  end)

0 describe("postVDFOutputAndProof", function()
0   setup(function()
      -- to execute before this describe
    end)

0   teardown(function()
    end)

0   it("should not be able to post output and proof from an unrequested provider for a valid request",
    function()
0     local output = "0x023456987678"
0     local proof = json.encode({"0x0567892345678", "fghjkl", "0x0567892345678", "fghjkl", "0x0567892345678", "0x0567892345678", "fghjkl", "0x0567892345678", "fghjkl", "0x0567892345678" })
0     local requestId = "d6cce35c-487a-458f-bab2-9032c2621f38"

0     local message = {
        Target = ao.id,
        From = "Provider2",
        Action = "Post-VDF-Output-And-Proof",
0       Data = json.encode({output = output, proof = proof, requestId = requestId})
      }

0     local success = postVDFChallengeHandler(message)
0     assert(not success, "Failure: able to post VDF output and proof from unrequested provider")
    end)

0   it("should not be able to post output and proof from an unrequested provider for an invalid request",
    function()
0     local output = "0x023456987678"
0     local proof = json.encode({"0x0567892345678", "fghjkl", "0x0567892345678", "fghjkl", "0x0567892345678", "0x0567892345678", "fghjkl", "0x0567892345678", "fghjkl", "0x0567892345678" })
0     local requestId = "a6cce35c-487a-458f-bab2-9032c2621f38"

0     local message = {
        Target = ao.id,
        From = "Provider2",
        Action = "Post-VDF-Output-And-Proof",
0       Data = json.encode({output = output, proof = proof, requestId = requestId})
      }

0     local success = postVDFOutputAndProofHandler(message)
0     assert(not success, "Failure: able to post VDF output and proof from unrequested provider")
    end)

0   it("should not be able to post output with no proof from a requested provider for a valid request",
    function()
0     local output = "0x023456987678"
0     local requestId = "d6cce35c-487a-458f-bab2-9032c2621f38"

0     local message = {
        Target = ao.id,
        From = "Provider1",
        Action = "Post-VDF-Output-And-Proof",
0       Data = json.encode({output = output, requestId = requestId})
      }

0     local success = postVDFOutputAndProofHandler(message)
0     assert(not success, "Failure: able to post VDF no output and proof from requested provider")
    end)

0   it("should not be able to post no output with proof from a requested provider for a valid request",
    function()
0     local proof = json.encode({"0x0567892345678", "fghjkl", "0x0567892345678", "fghjkl", "0x0567892345678", "0x0567892345678", "fghjkl", "0x0567892345678", "fghjkl", "0x0567892345678" })
0     local requestId = "d6cce35c-487a-458f-bab2-9032c2621f38"

0     local message = {
        Target = ao.id,
        From = "Provider1",
        Action = "Post-VDF-Output-And-Proof",
0       Data = json.encode({proof = proof, requestId = requestId})
      }

0     local success = postVDFOutputAndProofHandler(message)
0     assert(not success, "Failure: able to post VDF no output and proof from requested provider")
    end)

0   it("should be able to post output and proof from a requested provider for a valid request",
    function()
0     local output = "0x023456987678"
0     local proof = json.encode({"erwsztxdyfcuj", "ztrdyxufc", "ARTSzydxujf", "RTz", "tzyhdxjf", "TSYzu", "RTYzux", "tmrngb", "kumjtnyhbtdgv", "kyumtjynjrhbhg" })
0     local requestId = "d6cce35c-487a-458f-bab2-9032c2621f38"

0     local message = {
        Target = ao.id,
        From = "Provider1",
        Action = "Post-VDF-Output-And-Proof",
0       Data = json.encode({output = output, proof = proof, requestId = requestId})
      }

0     local success = postVDFOutputAndProofHandler(message)
0     assert(success, "Failure: unable to post VDF output and proof from requested provider")
    end)

0   it("should not be able to post output and proof from a requested provider for a valid request twice",
    function()
0     local output = "0x023456987678"
0     local proof = json.encode({"0x0567892345678", "fghjkl", "0x0567892345678", "fghjkl", "0x0567892345678", "0x0567892345678", "fghjkl", "0x0567892345678", "fghjkl", "0x0567892345678" })
0     local requestId = "d6cce35c-487a-458f-bab2-9032c2621f38"

0     local message = {
        Target = ao.id,
        From = "Provider1",
        Action = "Post-VDF-Output-And-Proof",
0       Data = json.encode({output = output, proof = proof, requestId = requestId})
      }

0     local success = postVDFOutputAndProofHandler(message)
0     assert(not success, "Failure: able to post VDF output and proof from requested provider twice")
    end)

0   it("should be able to post output and proof from the second requested provider for a valid request",
    function()
0     local output = "0x023456987678"
0     local proof = json.encode({"srtxdyfu", "dfgfh", "sztgdh", "aeyduxficgk", "yucfi", "xuctyurvi", "wrstedf", "warstdxyfcjg", "ARSztgdxhfcj", "rztswyxduf" })
0     local requestId = "d6cce35c-487a-458f-bab2-9032c2621f38"

0     local message = {
        Target = ao.id,
        From = "Provider3",
        Action = "Post-VDF-Output-And-Proof",
0       Data = json.encode({output = output, proof = proof, requestId = requestId})
      }

0     local success = postVDFOutputAndProofHandler(message)
0     assert(success, "Failure: unable to post VDF output and proof from the second requested provider")
    end)
  end)

0 describe("getRandomRequests & getRandomRequestViaCallbackId", function()
0   setup(function()
      -- to execute before this describe
    end)

0   teardown(function()
    end)

0   it("should not error on valid requestIds",
    function()
0     local requestIds = {"d6cce35c-487a-458f-bab2-9032c2621f38"}

0     local message = {
        Target = ao.id,
        From = "Provider1",
        Action = "Get-Random-Requests",
0       Data = json.encode({requestIds = requestIds})
      }

0     local success = getRandomRequestsHandler(message)
0     assert(success, "Failure: errors out on valid requestIds")
    end)

0   it("should not error on invalid requestIds",
    function()
0     local requestIds = {"d6cce35c-487a-458f-bab2-9032c2621f38", "A6cce35c-487a-458f-bab2-9032c2621f38"}

0     local message = {
        Target = ao.id,
        From = "Provider1",
        Action = "Get-Random-Requests",
0       Data = json.encode({requestIds = requestIds})
      }

0     local success = getRandomRequestsHandler(message)
0     assert(success, "Failure: errors out on invalid requestIds")
    end)

0   it("should not error on valid callbackId",
    function()
0     local callbackId = "xxxx-xxxx-4xxx-xxxx"

0     local message = {
        Target = ao.id,
        From = "Provider1",
        Action = "Get-Random-Request-Via-Callback-Id",
        Data = json.encode({callbackId = callbackId}),
        reply = function (msg)
          -- print("replied: " .. json.encode(msg))
        end
      }

0     local success = getRandomRequestViaCallbackIdHandler(message)
0     assert(success, "Failure: errors out on valid callbackId")
    end)


0   it("should not error on invalid callbackId",
    function()
0     local callbackId = "xxxx-xxxx-4xxx-xxx"

0     local message = {
        Target = ao.id,
        From = "Provider1",
        Action = "Get-Random-Request-Via-Callback-Id",
        Data = json.encode({callbackId = callbackId}),
        reply = function (msg)
          -- print("replied: " .. json.encode(msg))
        end
      }

0     local success = getRandomRequestViaCallbackIdHandler(message)
0     assert(success, "Failure: errors out on invalid callbackId")
    end)
  end)

==============================================================================
test/mocked-env/processes/verifier.lua
==============================================================================
* local json = require "json"

  local function newmodule(selfId)
*   local verifier = {}

*   local ao = require "ao" (selfId)

*   verifier.mockBalance = "100"



*   function verifier.handle(msg)
0     if msg.Tags.Action == "Validate-Checkpoint" then
0         print("Verifying checkpoint")
0         local msgData = json.decode(msg.Data)

0         local data = {
              request_id = msgData.request_id,
              segment_id = msgData.segment_id,
0             valid = true
          }

0         msg.reply({Data=json.encode(data)})
      end
    end

*   return verifier
  end
* return newmodule

==============================================================================
test/mocked-env/processes/aocred.lua
==============================================================================
0 local json = require "json"

  local function newmodule(selfId)
0   local aocred = {}

0   local ao = require "ao" (selfId)

0   aocred.mockBalance = "100"

0   function aocred.handle(msg)
0     if msg.Tags.Action == "Balance" then
0       ao.send({ Target = _G.MainProcessId, Balance = aocred.mockBalance })
      end
    end

0   return aocred
  end
0 return newmodule

==============================================================================
test/mocked-env/lib/utils.lua
==============================================================================
* local utils = { _version = "0.0.2" }

  local function isArray(table)
0   if type(table) == "table" then
0       local maxIndex = 0
0       for k, v in pairs(table) do
0           if type(k) ~= "number" or k < 1 or math.floor(k) ~= k then
0               return false -- If there's a non-integer key, it's not an array
            end
0           maxIndex = math.max(maxIndex, k)
        end
        -- If the highest numeric index is equal to the number of elements, it's an array
0       return maxIndex == #table
    end
0   return false
  end

  -- @param {function} fn
  -- @param {number} arity
  utils.curry = function (fn, arity)
*   assert(type(fn) == "function", "function is required as first argument")
*   arity = arity or debug.getinfo(fn, "u").nparams
*   if arity < 2 then return fn end

    return function (...)
0     local args = {...}

0     if #args >= arity then
0       return fn(table.unpack(args))
      else
0       return utils.curry(function (...)
0         return fn(table.unpack(args),  ...)
0       end, arity - #args)
      end
    end
  end

  --- Concat two Array Tables.
  -- @param {table<Array>} a
  -- @param {table<Array>} b
* utils.concat = utils.curry(function (a, b)
0   assert(type(a) == "table", "first argument should be a table that is an array")
0   assert(type(b) == "table", "second argument should be a table that is an array")
0   assert(isArray(a), "first argument should be a table")
0   assert(isArray(b), "second argument should be a table")

0   local result = {}
0   for i = 1, #a do
0       result[#result + 1] = a[i]
    end
0   for i = 1, #b do
0       result[#result + 1] = b[i]
    end
0   return result
* end, 2)

  --- reduce applies a function to a table
  -- @param {function} fn
  -- @param {any} initial
  -- @param {table<Array>} t
* utils.reduce = utils.curry(function (fn, initial, t)
0   assert(type(fn) == "function", "first argument should be a function that accepts (result, value, key)")
0   assert(type(t) == "table" and isArray(t), "third argument should be a table that is an array")
0   local result = initial
0   for k, v in pairs(t) do
0     if result == nil then
0       result = v
      else
0       result = fn(result, v, k)
      end
    end
0   return result
* end, 3)

  -- @param {function} fn
  -- @param {table<Array>} data
* utils.map = utils.curry(function (fn, data)
0   assert(type(fn) == "function", "first argument should be a unary function")
0   assert(type(data) == "table" and isArray(data), "second argument should be an Array")

    local function map (result, v, k)
0     result[k] = fn(v, k)
0     return result
    end

0   return utils.reduce(map, {}, data)
* end, 2)

  -- @param {function} fn
  -- @param {table<Array>} data
* utils.filter = utils.curry(function (fn, data)
0   assert(type(fn) == "function", "first argument should be a unary function")
0   assert(type(data) == "table" and isArray(data), "second argument should be an Array")

    local function filter (result, v, _k)
0     if fn(v) then
0       table.insert(result, v)
      end
0     return result
    end

0   return utils.reduce(filter,{}, data)
* end, 2)

  -- @param {function} fn
  -- @param {table<Array>} t
* utils.find = utils.curry(function (fn, t)
0   assert(type(fn) == "function", "first argument should be a unary function")
0   assert(type(t) == "table", "second argument should be a table that is an array")
0   for _, v in pairs(t) do
0     if fn(v) then
0       return v
      end
    end
* end, 2)

  -- @param {string} propName
  -- @param {string} value 
  -- @param {table} object
* utils.propEq = utils.curry(function (propName, value, object)
0   assert(type(propName) == "string", "first argument should be a string")
    -- assert(type(value) == "string", "second argument should be a string")
0   assert(type(object) == "table", "third argument should be a table<object>")
    
0   return object[propName] == value
* end, 3)

  -- @param {table<Array>} data
  utils.reverse = function (data)
0   assert(type(data) == "table", "argument needs to be a table that is an array")
0   return utils.reduce(
      function (result, v, i)
0       result[#data - i + 1] = v
0       return result
      end,
      {},
      data
    )
  end

  -- @param {function} ... 
* utils.compose = utils.curry(function (...)
0   local mutations = utils.reverse({...})

    return function (v)
0     local result = v
0     for _, fn in pairs(mutations) do
0       assert(type(fn) == "function", "each argument needs to be a function")
0       result = fn(result)
      end
0     return result
    end
* end, 2)

  -- @param {string} propName
  -- @param {table} object
* utils.prop = utils.curry(function (propName, object) 
0   return object[propName]
* end, 2)

  -- @param {any} val
  -- @param {table<Array>} t
* utils.includes = utils.curry(function (val, t)
0   assert(type(t) == "table", "argument needs to be a table")
0   return utils.find(function (v) return v == val end, t) ~= nil
* end, 2)

  -- @param {table} t
  utils.keys = function (t)
0   assert(type(t) == "table", "argument needs to be a table")
0   local keys = {}
0   for key in pairs(t) do
0     table.insert(keys, key)
    end
0   return keys
  end

  -- @param {table} t
  utils.values = function (t)
0   assert(type(t) == "table", "argument needs to be a table")
0   local values = {}
0   for _, value in pairs(t) do
0     table.insert(values, value)
    end
0   return values
  end

* return utils

==============================================================================
test/mocked-env/lib/bint.lua
==============================================================================
  --[[--
  lua-bint - v0.5.1 - 26/Jun/2023
  Eduardo Bart - edub4rt@gmail.com
  https://github.com/edubart/lua-bint

  Small portable arbitrary-precision integer arithmetic library in pure Lua for
  computing with large integers.

  Different from most arbitrary-precision integer libraries in pure Lua out there this one
  uses an array of lua integers as underlying data-type in its implementation instead of
  using strings or large tables, this make it efficient for working with fixed width integers
  and to make bitwise operations.

  ## Design goals

  The main design goal of this library is to be small, correct, self contained and use few
  resources while retaining acceptable performance and feature completeness.

  The library is designed to follow recent Lua integer semantics, this means that
  integer overflow warps around,
  signed integers are implemented using two-complement arithmetic rules,
  integer division operations rounds towards minus infinity,
  any mixed operations with float numbers promotes the value to a float,
  and the usual division/power operation always promotes to floats.

  The library is designed to be possible to work with only unsigned integer arithmetic
  when using the proper methods.

  All the lua arithmetic operators (+, -, *, //, /, %) and bitwise operators (&, |, ~, <<, >>)
  are implemented as metamethods.

  The integer size must be fixed in advance and the library is designed to be more efficient when
  working with integers of sizes between 64-4096 bits. If you need to work with really huge numbers
  without size restrictions then use another library. This choice has been made to have more efficiency
  in that specific size range.

  ## Usage

  First on you should require the bint file including how many bits the bint module will work with,
  by calling the returned function from the require, for example:

  ```lua
  local bint = require 'bint'(1024)
  ```

  For more information about its arguments see @{newmodule}.
  Then when you need create a bint, you can use one of the following functions:

  * @{bint.fromuinteger} (convert from lua integers, but read as unsigned integer)
  * @{bint.frominteger} (convert from lua integers, preserving the sign)
  * @{bint.frombase} (convert from arbitrary bases, like hexadecimal)
  * @{bint.fromstring} (convert from arbitrary string, support binary/hexadecimal/decimal)
  * @{bint.trunc} (convert from lua numbers, truncating the fractional part)
  * @{bint.new} (convert from anything, asserts on invalid integers)
  * @{bint.tobint} (convert from anything, returns nil on invalid integers)
  * @{bint.parse} (convert from anything, returns a lua number as fallback)
  * @{bint.zero}
  * @{bint.one}
  * `bint`

  You can also call `bint` as it is an alias to `bint.new`.
  In doubt use @{bint.new} to create a new bint.

  Then you can use all the usual lua numeric operations on it,
  all the arithmetic metamethods are implemented.
  When you are done computing and need to get the result,
  get the output from one of the following functions:

  * @{bint.touinteger} (convert to a lua integer, wraps around as an unsigned integer)
  * @{bint.tointeger} (convert to a lua integer, wraps around, preserves the sign)
  * @{bint.tonumber} (convert to lua float, losing precision)
  * @{bint.tobase} (convert to a string in any base)
  * @{bint.__tostring} (convert to a string in base 10)

  To output a very large integer with no loss you probably want to use @{bint.tobase}
  or call `tostring` to get a string representation.

  ## Precautions

  All library functions can be mixed with lua numbers,
  this makes easy to mix operations between bints and lua numbers,
  however the user should take care in some situations:

  * Don't mix integers and float operations if you want to work with integers only.
  * Don't use the regular equal operator ('==') to compare values from this library,
  unless you know in advance that both values are of the same primitive type,
  otherwise it will always return false, use @{bint.eq} to be safe.
  * Don't pass fractional numbers to functions that an integer is expected
  * Don't mix operations between bint classes with different sizes as this is not supported, this
  will throw assertions.
  * Remember that casting back to lua integers or numbers precision can be lost.
  * For dividing while preserving integers use the @{bint.__idiv} (the '//' operator).
  * For doing power operation preserving integers use the @{bint.ipow} function.
  * Configure the proper integer size you intend to work with, otherwise large integers may wrap around.

  ]]

  -- Returns number of bits of the internal lua integer type.
  local function luainteger_bitsize()
0   local n, i = -1, 0
    repeat
0     n, i = n >> 16, i + 16
0   until n == 0
0   return i
  end

0 local math_type = math.type
0 local math_floor = math.floor
0 local math_abs = math.abs
0 local math_ceil = math.ceil
0 local math_modf = math.modf
0 local math_mininteger = math.mininteger
0 local math_maxinteger = math.maxinteger
0 local math_max = math.max
0 local math_min = math.min
0 local string_format = string.format
0 local table_insert = table.insert
0 local table_concat = table.concat
0 local table_unpack = table.unpack

0 local memo = {}

  --- Create a new bint module representing integers of the desired bit size.
  -- This is the returned function when `require 'bint'` is called.
  -- @function newmodule
  -- @param bits Number of bits for the integer representation, must be multiple of wordbits and
  -- at least 64.
  -- @param[opt] wordbits Number of the bits for the internal word,
  -- defaults to half of Lua's integer size.
  local function newmodule(bits, wordbits)
0   local intbits = luainteger_bitsize()
0   bits = bits or 256
0   wordbits = wordbits or (intbits // 2)

    -- Memoize bint modules
0   local memoindex = bits * 64 + wordbits
0   if memo[memoindex] then
0     return memo[memoindex]
    end

    -- Validate
0   assert(bits % wordbits == 0, 'bitsize is not multiple of word bitsize')
0   assert(2 * wordbits <= intbits, 'word bitsize must be half of the lua integer bitsize')
0   assert(bits >= 64, 'bitsize must be >= 64')
0   assert(wordbits >= 8, 'wordbits must be at least 8')
0   assert(bits % 8 == 0, 'bitsize must be multiple of 8')

    -- Create bint module
0   local bint = {}
0   bint.__index = bint

    --- Number of bits representing a bint instance.
0   bint.bits = bits

    -- Constants used internally
0   local BINT_BITS = bits
0   local BINT_BYTES = bits // 8
0   local BINT_WORDBITS = wordbits
0   local BINT_SIZE = BINT_BITS // BINT_WORDBITS
0   local BINT_WORDMAX = (1 << BINT_WORDBITS) - 1
0   local BINT_WORDMSB = (1 << (BINT_WORDBITS - 1))
0   local BINT_LEPACKFMT = '<' .. ('I' .. (wordbits // 8)):rep(BINT_SIZE)
    local BINT_MATHMININTEGER, BINT_MATHMAXINTEGER
    local BINT_MININTEGER

    --- Create a new bint with 0 value.
0   function bint.zero()
0     local x = setmetatable({}, bint)
0     for i = 1, BINT_SIZE do
0       x[i] = 0
      end
0     return x
    end

0   local bint_zero = bint.zero

    --- Create a new bint with 1 value.
0   function bint.one()
0     local x = setmetatable({}, bint)
0     x[1] = 1
0     for i = 2, BINT_SIZE do
0       x[i] = 0
      end
0     return x
    end

0   local bint_one = bint.one

    -- Convert a value to a lua integer without losing precision.
    local function tointeger(x)
0     x = tonumber(x)
0     local ty = math_type(x)
0     if ty == 'float' then
0       local floorx = math_floor(x)
0       if floorx == x then
0         x = floorx
0         ty = math_type(x)
        end
      end
0     if ty == 'integer' then
0       return x
      end
    end

    --- Create a bint from an unsigned integer.
    -- Treats signed integers as an unsigned integer.
    -- @param x A value to initialize from convertible to a lua integer.
    -- @return A new bint or nil in case the input cannot be represented by an integer.
    -- @see bint.frominteger
0   function bint.fromuinteger(x)
0     x = tointeger(x)
0     if x then
0       if x == 1 then
0         return bint_one()
0       elseif x == 0 then
0         return bint_zero()
        end
0       local n = setmetatable({}, bint)
0       for i = 1, BINT_SIZE do
0         n[i] = x & BINT_WORDMAX
0         x = x >> BINT_WORDBITS
        end
0       return n
      end
    end

0   local bint_fromuinteger = bint.fromuinteger

    --- Create a bint from a signed integer.
    -- @param x A value to initialize from convertible to a lua integer.
    -- @return A new bint or nil in case the input cannot be represented by an integer.
    -- @see bint.fromuinteger
0   function bint.frominteger(x)
0     x = tointeger(x)
0     if x then
0       if x == 1 then
0         return bint_one()
0       elseif x == 0 then
0         return bint_zero()
        end
0       local neg = false
0       if x < 0 then
0         x = math_abs(x)
0         neg = true
        end
0       local n = setmetatable({}, bint)
0       for i = 1, BINT_SIZE do
0         n[i] = x & BINT_WORDMAX
0         x = x >> BINT_WORDBITS
        end
0       if neg then
0         n:_unm()
        end
0       return n
      end
    end

0   local bint_frominteger = bint.frominteger

0   local basesteps = {}

    -- Compute the read step for frombase function
    local function getbasestep(base)
0     local step = basesteps[base]
0     if step then
0       return step
      end
0     step = 0
0     local dmax = 1
0     local limit = math_maxinteger // base
      repeat
0       step = step + 1
0       dmax = dmax * base
0     until dmax >= limit
0     basesteps[base] = step
0     return step
    end

    -- Compute power with lua integers.
    local function ipow(y, x, n)
0     if n == 1 then
0       return y * x
0     elseif n & 1 == 0 then --even
0       return ipow(y, x * x, n // 2)
      end
0     return ipow(x * y, x * x, (n - 1) // 2)
    end

    --- Create a bint from a string of the desired base.
    -- @param s The string to be converted from,
    -- must have only alphanumeric and '+-' characters.
    -- @param[opt] base Base that the number is represented, defaults to 10.
    -- Must be at least 2 and at most 36.
    -- @return A new bint or nil in case the conversion failed.
0   function bint.frombase(s, base)
0     if type(s) ~= 'string' then
0       return
      end
0     base = base or 10
0     if not (base >= 2 and base <= 36) then
        -- number base is too large
0       return
      end
0     local step = getbasestep(base)
0     if #s < step then
        -- string is small, use tonumber (faster)
0       return bint_frominteger(tonumber(s, base))
      end
0     local sign, int = s:lower():match('^([+-]?)(%w+)$')
0     if not (sign and int) then
        -- invalid integer string representation
0       return
      end
0     local n = bint_zero()
0     for i = 1, #int, step do
0       local part = int:sub(i, i + step - 1)
0       local d = tonumber(part, base)
0       if not d then
          -- invalid integer string representation
0         return
        end
0       if i > 1 then
0         n = n * ipow(1, base, #part)
        end
0       if d ~= 0 then
0         n:_add(d)
        end
      end
0     if sign == '-' then
0       n:_unm()
      end
0     return n
    end

0   local bint_frombase = bint.frombase

    --- Create a new bint from a string.
    -- The string can by a decimal number, binary number prefixed with '0b' or hexadecimal number prefixed with '0x'.
    -- @param s A string convertible to a bint.
    -- @return A new bint or nil in case the conversion failed.
    -- @see bint.frombase
0   function bint.fromstring(s)
0     if type(s) ~= 'string' then
0       return
      end
0     if s:find('^[+-]?[0-9]+$') then
0       return bint_frombase(s, 10)
0     elseif s:find('^[+-]?0[xX][0-9a-fA-F]+$') then
0       return bint_frombase(s:gsub('0[xX]', '', 1), 16)
0     elseif s:find('^[+-]?0[bB][01]+$') then
0       return bint_frombase(s:gsub('0[bB]', '', 1), 2)
      end
    end

0   local bint_fromstring = bint.fromstring

    --- Create a new bint from a buffer of little-endian bytes.
    -- @param buffer Buffer of bytes, extra bytes are trimmed from the right, missing bytes are padded to the right.
    -- @raise An assert is thrown in case buffer is not an string.
    -- @return A bint.
0   function bint.fromle(buffer)
0     assert(type(buffer) == 'string', 'buffer is not a string')
0     if #buffer > BINT_BYTES then     -- trim extra bytes from the right
0       buffer = buffer:sub(1, BINT_BYTES)
0     elseif #buffer < BINT_BYTES then -- add missing bytes to the right
0       buffer = buffer .. ('\x00'):rep(BINT_BYTES - #buffer)
      end
0     return setmetatable({ BINT_LEPACKFMT:unpack(buffer) }, bint)
    end

    --- Create a new bint from a buffer of big-endian bytes.
    -- @param buffer Buffer of bytes, extra bytes are trimmed from the left, missing bytes are padded to the left.
    -- @raise An assert is thrown in case buffer is not an string.
    -- @return A bint.
0   function bint.frombe(buffer)
0     assert(type(buffer) == 'string', 'buffer is not a string')
0     if #buffer > BINT_BYTES then     -- trim extra bytes from the left
0       buffer = buffer:sub(-BINT_BYTES, #buffer)
0     elseif #buffer < BINT_BYTES then -- add missing bytes to the left
0       buffer = ('\x00'):rep(BINT_BYTES - #buffer) .. buffer
      end
0     return setmetatable({ BINT_LEPACKFMT:unpack(buffer:reverse()) }, bint)
    end

    --- Create a new bint from a value.
    -- @param x A value convertible to a bint (string, number or another bint).
    -- @return A new bint, guaranteed to be a new reference in case needed.
    -- @raise An assert is thrown in case x is not convertible to a bint.
    -- @see bint.tobint
    -- @see bint.parse
0   function bint.new(x)
0     if getmetatable(x) ~= bint then
0       local ty = type(x)
0       if ty == 'number' then
0         x = bint_frominteger(x)
0       elseif ty == 'string' then
0         x = bint_fromstring(x)
        end
0       assert(x, 'value cannot be represented by a bint')
0       return x
      end
      -- return a clone
0     local n = setmetatable({}, bint)
0     for i = 1, BINT_SIZE do
0       n[i] = x[i]
      end
0     return n
    end

0   local bint_new = bint.new

    --- Convert a value to a bint if possible.
    -- @param x A value to be converted (string, number or another bint).
    -- @param[opt] clone A boolean that tells if a new bint reference should be returned.
    -- Defaults to false.
    -- @return A bint or nil in case the conversion failed.
    -- @see bint.new
    -- @see bint.parse
0   function bint.tobint(x, clone)
0     if getmetatable(x) == bint then
0       if not clone then
0         return x
        end
        -- return a clone
0       local n = setmetatable({}, bint)
0       for i = 1, BINT_SIZE do
0         n[i] = x[i]
        end
0       return n
      end
0     local ty = type(x)
0     if ty == 'number' then
0       return bint_frominteger(x)
0     elseif ty == 'string' then
0       return bint_fromstring(x)
      end
    end

0   local tobint = bint.tobint

    --- Convert a value to a bint if possible otherwise to a lua number.
    -- Useful to prepare values that you are unsure if it's going to be an integer or float.
    -- @param x A value to be converted (string, number or another bint).
    -- @param[opt] clone A boolean that tells if a new bint reference should be returned.
    -- Defaults to false.
    -- @return A bint or a lua number or nil in case the conversion failed.
    -- @see bint.new
    -- @see bint.tobint
0   function bint.parse(x, clone)
0     local i = tobint(x, clone)
0     if i then
0       return i
      end
0     return tonumber(x)
    end

0   local bint_parse = bint.parse

    --- Convert a bint to an unsigned integer.
    -- Note that large unsigned integers may be represented as negatives in lua integers.
    -- Note that lua cannot represent values larger than 64 bits,
    -- in that case integer values wrap around.
    -- @param x A bint or a number to be converted into an unsigned integer.
    -- @return An integer or nil in case the input cannot be represented by an integer.
    -- @see bint.tointeger
0   function bint.touinteger(x)
0     if getmetatable(x) == bint then
0       local n = 0
0       for i = 1, BINT_SIZE do
0         n = n | (x[i] << (BINT_WORDBITS * (i - 1)))
        end
0       return n
      end
0     return tointeger(x)
    end

    --- Convert a bint to a signed integer.
    -- It works by taking absolute values then applying the sign bit in case needed.
    -- Note that lua cannot represent values larger than 64 bits,
    -- in that case integer values wrap around.
    -- @param x A bint or value to be converted into an unsigned integer.
    -- @return An integer or nil in case the input cannot be represented by an integer.
    -- @see bint.touinteger
0   function bint.tointeger(x)
0     if getmetatable(x) == bint then
0       local n = 0
0       local neg = x:isneg()
0       if neg then
0         x = -x
        end
0       for i = 1, BINT_SIZE do
0         n = n | (x[i] << (BINT_WORDBITS * (i - 1)))
        end
0       if neg then
0         n = -n
        end
0       return n
      end
0     return tointeger(x)
    end

0   local bint_tointeger = bint.tointeger

    local function bint_assert_tointeger(x)
0     x = bint_tointeger(x)
0     if not x then
0       error('value has no integer representation')
      end
0     return x
    end

    --- Convert a bint to a lua float in case integer would wrap around or lua integer otherwise.
    -- Different from @{bint.tointeger} the operation does not wrap around integers,
    -- but digits precision are lost in the process of converting to a float.
    -- @param x A bint or value to be converted into a lua number.
    -- @return A lua number or nil in case the input cannot be represented by a number.
    -- @see bint.tointeger
0   function bint.tonumber(x)
0     if getmetatable(x) == bint then
0       if x <= BINT_MATHMAXINTEGER and x >= BINT_MATHMININTEGER then
0         return x:tointeger()
        end
0       return tonumber(tostring(x))
      end
0     return tonumber(x)
    end

0   local bint_tonumber = bint.tonumber

    -- Compute base letters to use in bint.tobase
0   local BASE_LETTERS = {}
    do
0     for i = 1, 36 do
0       BASE_LETTERS[i - 1] = ('0123456789abcdefghijklmnopqrstuvwxyz'):sub(i, i)
      end
    end

    --- Convert a bint to a string in the desired base.
    -- @param x The bint to be converted from.
    -- @param[opt] base Base to be represented, defaults to 10.
    -- Must be at least 2 and at most 36.
    -- @param[opt] unsigned Whether to output as an unsigned integer.
    -- Defaults to false for base 10 and true for others.
    -- When unsigned is false the symbol '-' is prepended in negative values.
    -- @return A string representing the input.
    -- @raise An assert is thrown in case the base is invalid.
0   function bint.tobase(x, base, unsigned)
0     x = tobint(x)
0     if not x then
        -- x is a fractional float or something else
0       return
      end
0     base = base or 10
0     if not (base >= 2 and base <= 36) then
        -- number base is too large
0       return
      end
0     if unsigned == nil then
0       unsigned = base ~= 10
      end
0     local isxneg = x:isneg()
0     if (base == 10 and not unsigned) or (base == 16 and unsigned and not isxneg) then
0       if x <= BINT_MATHMAXINTEGER and x >= BINT_MATHMININTEGER then
          -- integer is small, use tostring or string.format (faster)
0         local n = x:tointeger()
0         if base == 10 then
0           return tostring(n)
0         elseif unsigned then
0           return string_format('%x', n)
          end
        end
      end
0     local ss = {}
0     local neg = not unsigned and isxneg
0     x = neg and x:abs() or bint_new(x)
0     local xiszero = x:iszero()
0     if xiszero then
0       return '0'
      end
      -- calculate basepow
0     local step = 0
0     local basepow = 1
0     local limit = (BINT_WORDMSB - 1) // base
      repeat
0       step = step + 1
0       basepow = basepow * base
0     until basepow >= limit
      -- serialize base digits
0     local size = BINT_SIZE
      local xd, carry, d
      repeat
        -- single word division
0       carry = 0
0       xiszero = true
0       for i = size, 1, -1 do
0         carry = carry | x[i]
0         d, xd = carry // basepow, carry % basepow
0         if xiszero and d ~= 0 then
0           size = i
0           xiszero = false
          end
0         x[i] = d
0         carry = xd << BINT_WORDBITS
        end
        -- digit division
0       for _ = 1, step do
0         xd, d = xd // base, xd % base
0         if xiszero and xd == 0 and d == 0 then
            -- stop on leading zeros
            break
          end
0         table_insert(ss, 1, BASE_LETTERS[d])
        end
0     until xiszero
0     if neg then
0       table_insert(ss, 1, '-')
      end
0     return table_concat(ss)
    end

    local function bint_assert_convert(x)
0     return assert(tobint(x), 'value has not integer representation')
    end

    --- Convert a bint to a buffer of little-endian bytes.
    -- @param x A bint or lua integer.
    -- @param[opt] trim If true, zero bytes on the right are trimmed.
    -- @return A buffer of bytes representing the input.
    -- @raise Asserts in case input is not convertible to an integer.
0   function bint.tole(x, trim)
0     x = bint_assert_convert(x)
0     local s = BINT_LEPACKFMT:pack(table_unpack(x))
0     if trim then
0       s = s:gsub('\x00+$', '')
0       if s == '' then
0         s = '\x00'
        end
      end
0     return s
    end

    --- Convert a bint to a buffer of big-endian bytes.
    -- @param x A bint or lua integer.
    -- @param[opt] trim If true, zero bytes on the left are trimmed.
    -- @return A buffer of bytes representing the input.
    -- @raise Asserts in case input is not convertible to an integer.
0   function bint.tobe(x, trim)
0     x = bint_assert_convert(x)
0     local s = BINT_LEPACKFMT:pack(table_unpack(x)):reverse()
0     if trim then
0       s = s:gsub('^\x00+', '')
0       if s == '' then
0         s = '\x00'
        end
      end
0     return s
    end

    --- Check if a number is 0 considering bints.
    -- @param x A bint or a lua number.
0   function bint.iszero(x)
0     if getmetatable(x) == bint then
0       for i = 1, BINT_SIZE do
0         if x[i] ~= 0 then
0           return false
          end
        end
0       return true
      end
0     return x == 0
    end

    --- Check if a number is 1 considering bints.
    -- @param x A bint or a lua number.
0   function bint.isone(x)
0     if getmetatable(x) == bint then
0       if x[1] ~= 1 then
0         return false
        end
0       for i = 2, BINT_SIZE do
0         if x[i] ~= 0 then
0           return false
          end
        end
0       return true
      end
0     return x == 1
    end

    --- Check if a number is -1 considering bints.
    -- @param x A bint or a lua number.
0   function bint.isminusone(x)
0     if getmetatable(x) == bint then
0       for i = 1, BINT_SIZE do
0         if x[i] ~= BINT_WORDMAX then
0           return false
          end
        end
0       return true
      end
0     return x == -1
    end

0   local bint_isminusone = bint.isminusone

    --- Check if the input is a bint.
    -- @param x Any lua value.
0   function bint.isbint(x)
0     return getmetatable(x) == bint
    end

    --- Check if the input is a lua integer or a bint.
    -- @param x Any lua value.
0   function bint.isintegral(x)
0     return getmetatable(x) == bint or math_type(x) == 'integer'
    end

    --- Check if the input is a bint or a lua number.
    -- @param x Any lua value.
0   function bint.isnumeric(x)
0     return getmetatable(x) == bint or type(x) == 'number'
    end

    --- Get the number type of the input (bint, integer or float).
    -- @param x Any lua value.
    -- @return Returns "bint" for bints, "integer" for lua integers,
    -- "float" from lua floats or nil otherwise.
0   function bint.type(x)
0     if getmetatable(x) == bint then
0       return 'bint'
      end
0     return math_type(x)
    end

    --- Check if a number is negative considering bints.
    -- Zero is guaranteed to never be negative for bints.
    -- @param x A bint or a lua number.
0   function bint.isneg(x)
0     if getmetatable(x) == bint then
0       return x[BINT_SIZE] & BINT_WORDMSB ~= 0
      end
0     return x < 0
    end

0   local bint_isneg = bint.isneg

    --- Check if a number is positive considering bints.
    -- @param x A bint or a lua number.
0   function bint.ispos(x)
0     if getmetatable(x) == bint then
0       return not x:isneg() and not x:iszero()
      end
0     return x > 0
    end

    --- Check if a number is even considering bints.
    -- @param x A bint or a lua number.
0   function bint.iseven(x)
0     if getmetatable(x) == bint then
0       return x[1] & 1 == 0
      end
0     return math_abs(x) % 2 == 0
    end

    --- Check if a number is odd considering bints.
    -- @param x A bint or a lua number.
0   function bint.isodd(x)
0     if getmetatable(x) == bint then
0       return x[1] & 1 == 1
      end
0     return math_abs(x) % 2 == 1
    end

    --- Create a new bint with the maximum possible integer value.
0   function bint.maxinteger()
0     local x = setmetatable({}, bint)
0     for i = 1, BINT_SIZE - 1 do
0       x[i] = BINT_WORDMAX
      end
0     x[BINT_SIZE] = BINT_WORDMAX ~ BINT_WORDMSB
0     return x
    end

    --- Create a new bint with the minimum possible integer value.
0   function bint.mininteger()
0     local x = setmetatable({}, bint)
0     for i = 1, BINT_SIZE - 1 do
0       x[i] = 0
      end
0     x[BINT_SIZE] = BINT_WORDMSB
0     return x
    end

    --- Bitwise left shift a bint in one bit (in-place).
0   function bint:_shlone()
0     local wordbitsm1 = BINT_WORDBITS - 1
0     for i = BINT_SIZE, 2, -1 do
0       self[i] = ((self[i] << 1) | (self[i - 1] >> wordbitsm1)) & BINT_WORDMAX
      end
0     self[1] = (self[1] << 1) & BINT_WORDMAX
0     return self
    end

    --- Bitwise right shift a bint in one bit (in-place).
0   function bint:_shrone()
0     local wordbitsm1 = BINT_WORDBITS - 1
0     for i = 1, BINT_SIZE - 1 do
0       self[i] = ((self[i] >> 1) | (self[i + 1] << wordbitsm1)) & BINT_WORDMAX
      end
0     self[BINT_SIZE] = self[BINT_SIZE] >> 1
0     return self
    end

    -- Bitwise left shift words of a bint (in-place). Used only internally.
0   function bint:_shlwords(n)
0     for i = BINT_SIZE, n + 1, -1 do
0       self[i] = self[i - n]
      end
0     for i = 1, n do
0       self[i] = 0
      end
0     return self
    end

    -- Bitwise right shift words of a bint (in-place). Used only internally.
0   function bint:_shrwords(n)
0     if n < BINT_SIZE then
0       for i = 1, BINT_SIZE - n do
0         self[i] = self[i + n]
        end
0       for i = BINT_SIZE - n + 1, BINT_SIZE do
0         self[i] = 0
        end
      else
0       for i = 1, BINT_SIZE do
0         self[i] = 0
        end
      end
0     return self
    end

    --- Increment a bint by one (in-place).
0   function bint:_inc()
0     for i = 1, BINT_SIZE do
0       local tmp = self[i]
0       local v = (tmp + 1) & BINT_WORDMAX
0       self[i] = v
0       if v > tmp then
          break
        end
      end
0     return self
    end

    --- Increment a number by one considering bints.
    -- @param x A bint or a lua number to increment.
0   function bint.inc(x)
0     local ix = tobint(x, true)
0     if ix then
0       return ix:_inc()
      end
0     return x + 1
    end

    --- Decrement a bint by one (in-place).
0   function bint:_dec()
0     for i = 1, BINT_SIZE do
0       local tmp = self[i]
0       local v = (tmp - 1) & BINT_WORDMAX
0       self[i] = v
0       if v <= tmp then
          break
        end
      end
0     return self
    end

    --- Decrement a number by one considering bints.
    -- @param x A bint or a lua number to decrement.
0   function bint.dec(x)
0     local ix = tobint(x, true)
0     if ix then
0       return ix:_dec()
      end
0     return x - 1
    end

    --- Assign a bint to a new value (in-place).
    -- @param y A value to be copied from.
    -- @raise Asserts in case inputs are not convertible to integers.
0   function bint:_assign(y)
0     y = bint_assert_convert(y)
0     for i = 1, BINT_SIZE do
0       self[i] = y[i]
      end
0     return self
    end

    --- Take absolute of a bint (in-place).
0   function bint:_abs()
0     if self:isneg() then
0       self:_unm()
      end
0     return self
    end

    --- Take absolute of a number considering bints.
    -- @param x A bint or a lua number to take the absolute.
0   function bint.abs(x)
0     local ix = tobint(x, true)
0     if ix then
0       return ix:_abs()
      end
0     return math_abs(x)
    end

0   local bint_abs = bint.abs

    --- Take the floor of a number considering bints.
    -- @param x A bint or a lua number to perform the floor operation.
0   function bint.floor(x)
0     if getmetatable(x) == bint then
0       return bint_new(x)
      end
0     return bint_new(math_floor(tonumber(x)))
    end

    --- Take ceil of a number considering bints.
    -- @param x A bint or a lua number to perform the ceil operation.
0   function bint.ceil(x)
0     if getmetatable(x) == bint then
0       return bint_new(x)
      end
0     return bint_new(math_ceil(tonumber(x)))
    end

    --- Wrap around bits of an integer (discarding left bits) considering bints.
    -- @param x A bint or a lua integer.
    -- @param y Number of right bits to preserve.
0   function bint.bwrap(x, y)
0     x = bint_assert_convert(x)
0     if y <= 0 then
0       return bint_zero()
0     elseif y < BINT_BITS then
0       return x & (bint_one() << y):_dec()
      end
0     return bint_new(x)
    end

    --- Rotate left integer x by y bits considering bints.
    -- @param x A bint or a lua integer.
    -- @param y Number of bits to rotate.
0   function bint.brol(x, y)
0     x, y = bint_assert_convert(x), bint_assert_tointeger(y)
0     if y > 0 then
0       return (x << y) | (x >> (BINT_BITS - y))
0     elseif y < 0 then
0       if y ~= math_mininteger then
0         return x:bror(-y)
        else
0         x:bror(-(y + 1))
0         x:bror(1)
        end
      end
0     return x
    end

    --- Rotate right integer x by y bits considering bints.
    -- @param x A bint or a lua integer.
    -- @param y Number of bits to rotate.
0   function bint.bror(x, y)
0     x, y = bint_assert_convert(x), bint_assert_tointeger(y)
0     if y > 0 then
0       return (x >> y) | (x << (BINT_BITS - y))
0     elseif y < 0 then
0       if y ~= math_mininteger then
0         return x:brol(-y)
        else
0         x:brol(-(y + 1))
0         x:brol(1)
        end
      end
0     return x
    end

    --- Truncate a number to a bint.
    -- Floats numbers are truncated, that is, the fractional port is discarded.
    -- @param x A number to truncate.
    -- @return A new bint or nil in case the input does not fit in a bint or is not a number.
0   function bint.trunc(x)
0     if getmetatable(x) ~= bint then
0       x = tonumber(x)
0       if x then
0         local ty = math_type(x)
0         if ty == 'float' then
            -- truncate to integer
0           x = math_modf(x)
          end
0         return bint_frominteger(x)
        end
0       return
      end
0     return bint_new(x)
    end

    --- Take maximum between two numbers considering bints.
    -- @param x A bint or lua number to compare.
    -- @param y A bint or lua number to compare.
    -- @return A bint or a lua number. Guarantees to return a new bint for integer values.
0   function bint.max(x, y)
0     local ix, iy = tobint(x), tobint(y)
0     if ix and iy then
0       return bint_new(ix > iy and ix or iy)
      end
0     return bint_parse(math_max(x, y))
    end

    --- Take minimum between two numbers considering bints.
    -- @param x A bint or lua number to compare.
    -- @param y A bint or lua number to compare.
    -- @return A bint or a lua number. Guarantees to return a new bint for integer values.
0   function bint.min(x, y)
0     local ix, iy = tobint(x), tobint(y)
0     if ix and iy then
0       return bint_new(ix < iy and ix or iy)
      end
0     return bint_parse(math_min(x, y))
    end

    --- Add an integer to a bint (in-place).
    -- @param y An integer to be added.
    -- @raise Asserts in case inputs are not convertible to integers.
0   function bint:_add(y)
0     y = bint_assert_convert(y)
0     local carry = 0
0     for i = 1, BINT_SIZE do
0       local tmp = self[i] + y[i] + carry
0       carry = tmp >> BINT_WORDBITS
0       self[i] = tmp & BINT_WORDMAX
      end
0     return self
    end

    --- Add two numbers considering bints.
    -- @param x A bint or a lua number to be added.
    -- @param y A bint or a lua number to be added.
0   function bint.__add(x, y)
0     local ix, iy = tobint(x), tobint(y)
0     if ix and iy then
0       local z = setmetatable({}, bint)
0       local carry = 0
0       for i = 1, BINT_SIZE do
0         local tmp = ix[i] + iy[i] + carry
0         carry = tmp >> BINT_WORDBITS
0         z[i] = tmp & BINT_WORDMAX
        end
0       return z
      end
0     return bint_tonumber(x) + bint_tonumber(y)
    end

    --- Subtract an integer from a bint (in-place).
    -- @param y An integer to subtract.
    -- @raise Asserts in case inputs are not convertible to integers.
0   function bint:_sub(y)
0     y = bint_assert_convert(y)
0     local borrow = 0
0     local wordmaxp1 = BINT_WORDMAX + 1
0     for i = 1, BINT_SIZE do
0       local res = self[i] + wordmaxp1 - y[i] - borrow
0       self[i] = res & BINT_WORDMAX
0       borrow = (res >> BINT_WORDBITS) ~ 1
      end
0     return self
    end

    --- Subtract two numbers considering bints.
    -- @param x A bint or a lua number to be subtracted from.
    -- @param y A bint or a lua number to subtract.
0   function bint.__sub(x, y)
0     local ix, iy = tobint(x), tobint(y)
0     if ix and iy then
0       local z = setmetatable({}, bint)
0       local borrow = 0
0       local wordmaxp1 = BINT_WORDMAX + 1
0       for i = 1, BINT_SIZE do
0         local res = ix[i] + wordmaxp1 - iy[i] - borrow
0         z[i] = res & BINT_WORDMAX
0         borrow = (res >> BINT_WORDBITS) ~ 1
        end
0       return z
      end
0     return bint_tonumber(x) - bint_tonumber(y)
    end

    --- Multiply two numbers considering bints.
    -- @param x A bint or a lua number to multiply.
    -- @param y A bint or a lua number to multiply.
0   function bint.__mul(x, y)
0     local ix, iy = tobint(x), tobint(y)
0     if ix and iy then
0       local z = bint_zero()
0       local sizep1 = BINT_SIZE + 1
0       local s = sizep1
0       local e = 0
0       for i = 1, BINT_SIZE do
0         if ix[i] ~= 0 or iy[i] ~= 0 then
0           e = math_max(e, i)
0           s = math_min(s, i)
          end
        end
0       for i = s, e do
0         for j = s, math_min(sizep1 - i, e) do
0           local a = ix[i] * iy[j]
0           if a ~= 0 then
0             local carry = 0
0             for k = i + j - 1, BINT_SIZE do
0               local tmp = z[k] + (a & BINT_WORDMAX) + carry
0               carry = tmp >> BINT_WORDBITS
0               z[k] = tmp & BINT_WORDMAX
0               a = a >> BINT_WORDBITS
              end
            end
          end
        end
0       return z
      end
0     return bint_tonumber(x) * bint_tonumber(y)
    end

    --- Check if bints are equal.
    -- @param x A bint to compare.
    -- @param y A bint to compare.
0   function bint.__eq(x, y)
0     for i = 1, BINT_SIZE do
0       if x[i] ~= y[i] then
0         return false
        end
      end
0     return true
    end

    --- Check if numbers are equal considering bints.
    -- @param x A bint or lua number to compare.
    -- @param y A bint or lua number to compare.
0   function bint.eq(x, y)
0     local ix, iy = tobint(x), tobint(y)
0     if ix and iy then
0       return ix == iy
      end
0     return x == y
    end

0   local bint_eq = bint.eq

    local function findleftbit(x)
0     for i = BINT_SIZE, 1, -1 do
0       local v = x[i]
0       if v ~= 0 then
0         local j = 0
          repeat
0           v = v >> 1
0           j = j + 1
0         until v == 0
0         return (i - 1) * BINT_WORDBITS + j - 1, i
        end
      end
    end

    -- Single word division modulus
    local function sudivmod(nume, deno)
      local rema
0     local carry = 0
0     for i = BINT_SIZE, 1, -1 do
0       carry = carry | nume[i]
0       nume[i] = carry // deno
0       rema = carry % deno
0       carry = rema << BINT_WORDBITS
      end
0     return rema
    end

    --- Perform unsigned division and modulo operation between two integers considering bints.
    -- This is effectively the same of @{bint.udiv} and @{bint.umod}.
    -- @param x The numerator, must be a bint or a lua integer.
    -- @param y The denominator, must be a bint or a lua integer.
    -- @return The quotient following the remainder, both bints.
    -- @raise Asserts on attempt to divide by zero
    -- or if inputs are not convertible to integers.
    -- @see bint.udiv
    -- @see bint.umod
0   function bint.udivmod(x, y)
0     local nume = bint_new(x)
0     local deno = bint_assert_convert(y)
      -- compute if high bits of denominator are all zeros
0     local ishighzero = true
0     for i = 2, BINT_SIZE do
0       if deno[i] ~= 0 then
0         ishighzero = false
          break
        end
      end
0     if ishighzero then
        -- try to divide by a single word (optimization)
0       local low = deno[1]
0       assert(low ~= 0, 'attempt to divide by zero')
0       if low == 1 then
          -- denominator is one
0         return nume, bint_zero()
0       elseif low <= (BINT_WORDMSB - 1) then
          -- can do single word division
0         local rema = sudivmod(nume, low)
0         return nume, bint_fromuinteger(rema)
        end
      end
0     if nume:ult(deno) then
        -- denominator is greater than numerator
0       return bint_zero(), nume
      end
      -- align leftmost digits in numerator and denominator
0     local denolbit = findleftbit(deno)
0     local numelbit, numesize = findleftbit(nume)
0     local bit = numelbit - denolbit
0     deno = deno << bit
0     local wordmaxp1 = BINT_WORDMAX + 1
0     local wordbitsm1 = BINT_WORDBITS - 1
0     local denosize = numesize
0     local quot = bint_zero()
0     while bit >= 0 do
        -- compute denominator <= numerator
0       local le = true
0       local size = math_max(numesize, denosize)
0       for i = size, 1, -1 do
0         local a, b = deno[i], nume[i]
0         if a ~= b then
0           le = a < b
            break
          end
        end
        -- if the portion of the numerator above the denominator is greater or equal than to the denominator
0       if le then
          -- subtract denominator from the portion of the numerator
0         local borrow = 0
0         for i = 1, size do
0           local res = nume[i] + wordmaxp1 - deno[i] - borrow
0           nume[i] = res & BINT_WORDMAX
0           borrow = (res >> BINT_WORDBITS) ~ 1
          end
          -- concatenate 1 to the right bit of the quotient
0         local i = (bit // BINT_WORDBITS) + 1
0         quot[i] = quot[i]| (1 << (bit % BINT_WORDBITS))
        end
        -- shift right the denominator in one bit
0       for i = 1, denosize - 1 do
0         deno[i] = ((deno[i] >> 1) | (deno[i + 1] << wordbitsm1)) & BINT_WORDMAX
        end
0       local lastdenoword = deno[denosize] >> 1
0       deno[denosize] = lastdenoword
        -- recalculate denominator size (optimization)
0       if lastdenoword == 0 then
0         while deno[denosize] == 0 do
0           denosize = denosize - 1
          end
0         if denosize == 0 then
            break
          end
        end
        -- decrement current set bit for the quotient
0       bit = bit - 1
      end
      -- the remaining numerator is the remainder
0     return quot, nume
    end

0   local bint_udivmod = bint.udivmod

    --- Perform unsigned division between two integers considering bints.
    -- @param x The numerator, must be a bint or a lua integer.
    -- @param y The denominator, must be a bint or a lua integer.
    -- @return The quotient, a bint.
    -- @raise Asserts on attempt to divide by zero
    -- or if inputs are not convertible to integers.
0   function bint.udiv(x, y)
0     return (bint_udivmod(x, y))
    end

    --- Perform unsigned integer modulo operation between two integers considering bints.
    -- @param x The numerator, must be a bint or a lua integer.
    -- @param y The denominator, must be a bint or a lua integer.
    -- @return The remainder, a bint.
    -- @raise Asserts on attempt to divide by zero
    -- or if the inputs are not convertible to integers.
0   function bint.umod(x, y)
0     local _, rema = bint_udivmod(x, y)
0     return rema
    end

0   local bint_umod = bint.umod

    --- Perform integer truncate division and modulo operation between two numbers considering bints.
    -- This is effectively the same of @{bint.tdiv} and @{bint.tmod}.
    -- @param x The numerator, a bint or lua number.
    -- @param y The denominator, a bint or lua number.
    -- @return The quotient following the remainder, both bint or lua number.
    -- @raise Asserts on attempt to divide by zero or on division overflow.
    -- @see bint.tdiv
    -- @see bint.tmod
0   function bint.tdivmod(x, y)
0     local ax, ay = bint_abs(x), bint_abs(y)
0     local ix, iy = tobint(ax), tobint(ay)
      local quot, rema
0     if ix and iy then
0       assert(not (bint_eq(x, BINT_MININTEGER) and bint_isminusone(y)), 'division overflow')
0       quot, rema = bint_udivmod(ix, iy)
      else
0       quot, rema = ax // ay, ax % ay
      end
0     local isxneg, isyneg = bint_isneg(x), bint_isneg(y)
0     if isxneg ~= isyneg then
0       quot = -quot
      end
0     if isxneg then
0       rema = -rema
      end
0     return quot, rema
    end

0   local bint_tdivmod = bint.tdivmod

    --- Perform truncate division between two numbers considering bints.
    -- Truncate division is a division that rounds the quotient towards zero.
    -- @param x The numerator, a bint or lua number.
    -- @param y The denominator, a bint or lua number.
    -- @return The quotient, a bint or lua number.
    -- @raise Asserts on attempt to divide by zero or on division overflow.
0   function bint.tdiv(x, y)
0     return (bint_tdivmod(x, y))
    end

    --- Perform integer truncate modulo operation between two numbers considering bints.
    -- The operation is defined as the remainder of the truncate division
    -- (division that rounds the quotient towards zero).
    -- @param x The numerator, a bint or lua number.
    -- @param y The denominator, a bint or lua number.
    -- @return The remainder, a bint or lua number.
    -- @raise Asserts on attempt to divide by zero or on division overflow.
0   function bint.tmod(x, y)
0     local _, rema = bint_tdivmod(x, y)
0     return rema
    end

    --- Perform integer floor division and modulo operation between two numbers considering bints.
    -- This is effectively the same of @{bint.__idiv} and @{bint.__mod}.
    -- @param x The numerator, a bint or lua number.
    -- @param y The denominator, a bint or lua number.
    -- @return The quotient following the remainder, both bint or lua number.
    -- @raise Asserts on attempt to divide by zero.
    -- @see bint.__idiv
    -- @see bint.__mod
0   function bint.idivmod(x, y)
0     local ix, iy = tobint(x), tobint(y)
0     if ix and iy then
0       local isnumeneg = ix[BINT_SIZE] & BINT_WORDMSB ~= 0
0       local isdenoneg = iy[BINT_SIZE] & BINT_WORDMSB ~= 0
0       if isnumeneg then
0         ix = -ix
        end
0       if isdenoneg then
0         iy = -iy
        end
0       local quot, rema = bint_udivmod(ix, iy)
0       if isnumeneg ~= isdenoneg then
0         quot:_unm()
          -- round quotient towards minus infinity
0         if not rema:iszero() then
0           quot:_dec()
            -- adjust the remainder
0           if isnumeneg and not isdenoneg then
0             rema:_unm():_add(y)
0           elseif isdenoneg and not isnumeneg then
0             rema:_add(y)
            end
          end
0       elseif isnumeneg then
          -- adjust the remainder
0         rema:_unm()
        end
0       return quot, rema
      end
0     local nx, ny = bint_tonumber(x), bint_tonumber(y)
0     return nx // ny, nx % ny
    end

0   local bint_idivmod = bint.idivmod

    --- Perform floor division between two numbers considering bints.
    -- Floor division is a division that rounds the quotient towards minus infinity,
    -- resulting in the floor of the division of its operands.
    -- @param x The numerator, a bint or lua number.
    -- @param y The denominator, a bint or lua number.
    -- @return The quotient, a bint or lua number.
    -- @raise Asserts on attempt to divide by zero.
0   function bint.__idiv(x, y)
0     local ix, iy = tobint(x), tobint(y)
0     if ix and iy then
0       local isnumeneg = ix[BINT_SIZE] & BINT_WORDMSB ~= 0
0       local isdenoneg = iy[BINT_SIZE] & BINT_WORDMSB ~= 0
0       if isnumeneg then
0         ix = -ix
        end
0       if isdenoneg then
0         iy = -iy
        end
0       local quot, rema = bint_udivmod(ix, iy)
0       if isnumeneg ~= isdenoneg then
0         quot:_unm()
          -- round quotient towards minus infinity
0         if not rema:iszero() then
0           quot:_dec()
          end
        end
0       return quot, rema
      end
0     return bint_tonumber(x) // bint_tonumber(y)
    end

    --- Perform division between two numbers considering bints.
    -- This always casts inputs to floats, for integer division only use @{bint.__idiv}.
    -- @param x The numerator, a bint or lua number.
    -- @param y The denominator, a bint or lua number.
    -- @return The quotient, a lua number.
0   function bint.__div(x, y)
0     return bint_tonumber(x) / bint_tonumber(y)
    end

    --- Perform integer floor modulo operation between two numbers considering bints.
    -- The operation is defined as the remainder of the floor division
    -- (division that rounds the quotient towards minus infinity).
    -- @param x The numerator, a bint or lua number.
    -- @param y The denominator, a bint or lua number.
    -- @return The remainder, a bint or lua number.
    -- @raise Asserts on attempt to divide by zero.
0   function bint.__mod(x, y)
0     local _, rema = bint_idivmod(x, y)
0     return rema
    end

    --- Perform integer power between two integers considering bints.
    -- If y is negative then pow is performed as an unsigned integer.
    -- @param x The base, an integer.
    -- @param y The exponent, an integer.
    -- @return The result of the pow operation, a bint.
    -- @raise Asserts in case inputs are not convertible to integers.
    -- @see bint.__pow
    -- @see bint.upowmod
0   function bint.ipow(x, y)
0     y = bint_assert_convert(y)
0     if y:iszero() then
0       return bint_one()
0     elseif y:isone() then
0       return bint_new(x)
      end
      -- compute exponentiation by squaring
0     x, y = bint_new(x), bint_new(y)
0     local z = bint_one()
      repeat
0       if y:iseven() then
0         x = x * x
0         y:_shrone()
        else
0         z = x * z
0         x = x * x
0         y:_dec():_shrone()
        end
0     until y:isone()
0     return x * z
    end

    --- Perform integer power between two unsigned integers over a modulus considering bints.
    -- @param x The base, an integer.
    -- @param y The exponent, an integer.
    -- @param m The modulus, an integer.
    -- @return The result of the pow operation, a bint.
    -- @raise Asserts in case inputs are not convertible to integers.
    -- @see bint.__pow
    -- @see bint.ipow
0   function bint.upowmod(x, y, m)
0     m = bint_assert_convert(m)
0     if m:isone() then
0       return bint_zero()
      end
0     x, y = bint_new(x), bint_new(y)
0     local z = bint_one()
0     x = bint_umod(x, m)
0     while not y:iszero() do
0       if y:isodd() then
0         z = bint_umod(z * x, m)
        end
0       y:_shrone()
0       x = bint_umod(x * x, m)
      end
0     return z
    end

    --- Perform numeric power between two numbers considering bints.
    -- This always casts inputs to floats, for integer power only use @{bint.ipow}.
    -- @param x The base, a bint or lua number.
    -- @param y The exponent, a bint or lua number.
    -- @return The result of the pow operation, a lua number.
    -- @see bint.ipow
0   function bint.__pow(x, y)
0     return bint_tonumber(x) ^ bint_tonumber(y)
    end

    --- Bitwise left shift integers considering bints.
    -- @param x An integer to perform the bitwise shift.
    -- @param y An integer with the number of bits to shift.
    -- @return The result of shift operation, a bint.
    -- @raise Asserts in case inputs are not convertible to integers.
0   function bint.__shl(x, y)
0     x, y = bint_new(x), bint_assert_tointeger(y)
0     if y == math_mininteger or math_abs(y) >= BINT_BITS then
0       return bint_zero()
      end
0     if y < 0 then
0       return x >> -y
      end
0     local nvals = y // BINT_WORDBITS
0     if nvals ~= 0 then
0       x:_shlwords(nvals)
0       y = y - nvals * BINT_WORDBITS
      end
0     if y ~= 0 then
0       local wordbitsmy = BINT_WORDBITS - y
0       for i = BINT_SIZE, 2, -1 do
0         x[i] = ((x[i] << y) | (x[i - 1] >> wordbitsmy)) & BINT_WORDMAX
        end
0       x[1] = (x[1] << y) & BINT_WORDMAX
      end
0     return x
    end

    --- Bitwise right shift integers considering bints.
    -- @param x An integer to perform the bitwise shift.
    -- @param y An integer with the number of bits to shift.
    -- @return The result of shift operation, a bint.
    -- @raise Asserts in case inputs are not convertible to integers.
0   function bint.__shr(x, y)
0     x, y = bint_new(x), bint_assert_tointeger(y)
0     if y == math_mininteger or math_abs(y) >= BINT_BITS then
0       return bint_zero()
      end
0     if y < 0 then
0       return x << -y
      end
0     local nvals = y // BINT_WORDBITS
0     if nvals ~= 0 then
0       x:_shrwords(nvals)
0       y = y - nvals * BINT_WORDBITS
      end
0     if y ~= 0 then
0       local wordbitsmy = BINT_WORDBITS - y
0       for i = 1, BINT_SIZE - 1 do
0         x[i] = ((x[i] >> y) | (x[i + 1] << wordbitsmy)) & BINT_WORDMAX
        end
0       x[BINT_SIZE] = x[BINT_SIZE] >> y
      end
0     return x
    end

    --- Bitwise AND bints (in-place).
    -- @param y An integer to perform bitwise AND.
    -- @raise Asserts in case inputs are not convertible to integers.
0   function bint:_band(y)
0     y = bint_assert_convert(y)
0     for i = 1, BINT_SIZE do
0       self[i] = self[i] & y[i]
      end
0     return self
    end

    --- Bitwise AND two integers considering bints.
    -- @param x An integer to perform bitwise AND.
    -- @param y An integer to perform bitwise AND.
    -- @raise Asserts in case inputs are not convertible to integers.
0   function bint.__band(x, y)
0     return bint_new(x):_band(y)
    end

    --- Bitwise OR bints (in-place).
    -- @param y An integer to perform bitwise OR.
    -- @raise Asserts in case inputs are not convertible to integers.
0   function bint:_bor(y)
0     y = bint_assert_convert(y)
0     for i = 1, BINT_SIZE do
0       self[i] = self[i]| y[i]
      end
0     return self
    end

    --- Bitwise OR two integers considering bints.
    -- @param x An integer to perform bitwise OR.
    -- @param y An integer to perform bitwise OR.
    -- @raise Asserts in case inputs are not convertible to integers.
0   function bint.__bor(x, y)
0     return bint_new(x):_bor(y)
    end

    --- Bitwise XOR bints (in-place).
    -- @param y An integer to perform bitwise XOR.
    -- @raise Asserts in case inputs are not convertible to integers.
0   function bint:_bxor(y)
0     y = bint_assert_convert(y)
0     for i = 1, BINT_SIZE do
0       self[i] = self[i] ~ y[i]
      end
0     return self
    end

    --- Bitwise XOR two integers considering bints.
    -- @param x An integer to perform bitwise XOR.
    -- @param y An integer to perform bitwise XOR.
    -- @raise Asserts in case inputs are not convertible to integers.
0   function bint.__bxor(x, y)
0     return bint_new(x):_bxor(y)
    end

    --- Bitwise NOT a bint (in-place).
0   function bint:_bnot()
0     for i = 1, BINT_SIZE do
0       self[i] = (~self[i]) & BINT_WORDMAX
      end
0     return self
    end

    --- Bitwise NOT a bint.
    -- @param x An integer to perform bitwise NOT.
    -- @raise Asserts in case inputs are not convertible to integers.
0   function bint.__bnot(x)
0     local y = setmetatable({}, bint)
0     for i = 1, BINT_SIZE do
0       y[i] = (~x[i]) & BINT_WORDMAX
      end
0     return y
    end

    --- Negate a bint (in-place). This effectively applies two's complements.
0   function bint:_unm()
0     return self:_bnot():_inc()
    end

    --- Negate a bint. This effectively applies two's complements.
    -- @param x A bint to perform negation.
0   function bint.__unm(x)
0     return (~x):_inc()
    end

    --- Compare if integer x is less than y considering bints (unsigned version).
    -- @param x Left integer to compare.
    -- @param y Right integer to compare.
    -- @raise Asserts in case inputs are not convertible to integers.
    -- @see bint.__lt
0   function bint.ult(x, y)
0     x, y = bint_assert_convert(x), bint_assert_convert(y)
0     for i = BINT_SIZE, 1, -1 do
0       local a, b = x[i], y[i]
0       if a ~= b then
0         return a < b
        end
      end
0     return false
    end

    --- Compare if bint x is less or equal than y considering bints (unsigned version).
    -- @param x Left integer to compare.
    -- @param y Right integer to compare.
    -- @raise Asserts in case inputs are not convertible to integers.
    -- @see bint.__le
0   function bint.ule(x, y)
0     x, y = bint_assert_convert(x), bint_assert_convert(y)
0     for i = BINT_SIZE, 1, -1 do
0       local a, b = x[i], y[i]
0       if a ~= b then
0         return a < b
        end
      end
0     return true
    end

    --- Compare if number x is less than y considering bints and signs.
    -- @param x Left value to compare, a bint or lua number.
    -- @param y Right value to compare, a bint or lua number.
    -- @see bint.ult
0   function bint.__lt(x, y)
0     local ix, iy = tobint(x), tobint(y)
0     if ix and iy then
0       local xneg = ix[BINT_SIZE] & BINT_WORDMSB ~= 0
0       local yneg = iy[BINT_SIZE] & BINT_WORDMSB ~= 0
0       if xneg == yneg then
0         for i = BINT_SIZE, 1, -1 do
0           local a, b = ix[i], iy[i]
0           if a ~= b then
0             return a < b
            end
          end
0         return false
        end
0       return xneg and not yneg
      end
0     return bint_tonumber(x) < bint_tonumber(y)
    end

    --- Compare if number x is less or equal than y considering bints and signs.
    -- @param x Left value to compare, a bint or lua number.
    -- @param y Right value to compare, a bint or lua number.
    -- @see bint.ule
0   function bint.__le(x, y)
0     local ix, iy = tobint(x), tobint(y)
0     if ix and iy then
0       local xneg = ix[BINT_SIZE] & BINT_WORDMSB ~= 0
0       local yneg = iy[BINT_SIZE] & BINT_WORDMSB ~= 0
0       if xneg == yneg then
0         for i = BINT_SIZE, 1, -1 do
0           local a, b = ix[i], iy[i]
0           if a ~= b then
0             return a < b
            end
          end
0         return true
        end
0       return xneg and not yneg
      end
0     return bint_tonumber(x) <= bint_tonumber(y)
    end

    --- Convert a bint to a string on base 10.
    -- @see bint.tobase
0   function bint:__tostring()
0     return self:tobase(10)
    end

    -- Allow creating bints by calling bint itself
0   setmetatable(bint, {
      __call = function(_, x)
0       return bint_new(x)
      end
    })

0   BINT_MATHMININTEGER, BINT_MATHMAXINTEGER = bint_new(math.mininteger), bint_new(math.maxinteger)
0   BINT_MININTEGER = bint.mininteger()
0   memo[memoindex] = bint

0   return bint
  end

0 return newmodule

==============================================================================
test/mocked-env/lib/json.lua
==============================================================================
  --
  -- json.lua
  --
  -- Copyright (c) 2020 rxi
  --
  -- Permission is hereby granted, free of charge, to any person obtaining a copy of
  -- this software and associated documentation files (the "Software"), to deal in
  -- the Software without restriction, including without limitation the rights to
  -- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
  -- of the Software, and to permit persons to whom the Software is furnished to do
  -- so, subject to the following conditions:
  --
  -- The above copyright notice and this permission notice shall be included in all
  -- copies or substantial portions of the Software.
  --
  -- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  -- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  -- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  -- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  -- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  -- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  -- SOFTWARE.
  --

* local json = { _version = "0.1.2" }

  -------------------------------------------------------------------------------
  -- Encode
  -------------------------------------------------------------------------------

  local encode

* local escape_char_map = {
*   ["\\"] = "\\",
*   ["\""] = "\"",
*   ["\b"] = "b",
*   ["\f"] = "f",
*   ["\n"] = "n",
*   ["\r"] = "r",
*   ["\t"] = "t",
  }

* local escape_char_map_inv = { ["/"] = "/" }
* for k, v in pairs(escape_char_map) do
*   escape_char_map_inv[v] = k
  end


  local function escape_char(c)
0   return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte()))
  end


  local function encode_nil(val)
0   return "null"
  end


  local function encode_table(val, stack)
0   local res = {}
0   stack = stack or {}

    -- Circular reference?
0   if stack[val] then error("circular reference") end

0   stack[val] = true

0   if rawget(val, 1) ~= nil or next(val) == nil then
      -- Treat as array -- check keys are valid and it is not sparse
0     local n = 0
0     for k in pairs(val) do
0       if type(k) ~= "number" then
0         error("invalid table: mixed or invalid key types")
        end
0       n = n + 1
      end
0     if n ~= #val then
0       error("invalid table: sparse array")
      end
      -- Encode
0     for i, v in ipairs(val) do
0       table.insert(res, encode(v, stack))
      end
0     stack[val] = nil
0     return "[" .. table.concat(res, ",") .. "]"
    else
      -- Treat as an object
0     for k, v in pairs(val) do
0       if type(k) ~= "string" then
0         error("invalid table: mixed or invalid key types")
        end
0       table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
      end
0     stack[val] = nil
0     return "{" .. table.concat(res, ",") .. "}"
    end
  end


  local function encode_string(val)
0   return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
  end


  local function encode_number(val)
    -- Check for NaN, -inf and inf
0   if val ~= val or val <= -math.huge or val >= math.huge then
0     error("unexpected number value '" .. tostring(val) .. "'")
    end
0   return string.format("%.14g", val)
  end


* local type_func_map = {
*   ["nil"] = encode_nil,
*   ["table"] = encode_table,
*   ["string"] = encode_string,
*   ["number"] = encode_number,
*   ["boolean"] = tostring,
  }


  encode = function(val, stack)
0   local t = type(val)
0   local f = type_func_map[t]
0   if f then
0     return f(val, stack)
    end
0   error("unexpected type '" .. t .. "'")
  end


* function json.encode(val)
0   return (encode(val))
  end

  -------------------------------------------------------------------------------
  -- Decode
  -------------------------------------------------------------------------------

  local parse

  local function create_set(...)
*   local res = {}
*   for i = 1, select("#", ...) do
*     res[select(i, ...)] = true
    end
*   return res
  end

* local space_chars  = create_set(" ", "\t", "\r", "\n")
* local delim_chars  = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
* local escape_chars = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
* local literals     = create_set("true", "false", "null")

* local literal_map  = {
*   ["true"] = true,
*   ["false"] = false,
*   ["null"] = nil,
  }


  local function next_char(str, idx, set, negate)
0   for i = idx, #str do
0     if set[str:sub(i, i)] ~= negate then
0       return i
      end
    end
0   return #str + 1
  end


  local function decode_error(str, idx, msg)
0   local line_count = 1
0   local col_count = 1
0   for i = 1, idx - 1 do
0     col_count = col_count + 1
0     if str:sub(i, i) == "\n" then
0       line_count = line_count + 1
0       col_count = 1
      end
    end
0   error(string.format("%s at line %d col %d", msg, line_count, col_count))
  end


  local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
0   local f = math.floor
0   if n <= 0x7f then
0     return string.char(n)
0   elseif n <= 0x7ff then
0     return string.char(f(n / 64) + 192, n % 64 + 128)
0   elseif n <= 0xffff then
0     return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
0   elseif n <= 0x10ffff then
0     return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
0       f(n % 4096 / 64) + 128, n % 64 + 128)
    end
0   error(string.format("invalid unicode codepoint '%x'", n))
  end


  local function parse_unicode_escape(s)
0   local n1 = tonumber(s:sub(1, 4), 16)
0   local n2 = tonumber(s:sub(7, 10), 16)
    -- Surrogate pair?
0   if n2 then
0     return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
0     return codepoint_to_utf8(n1)
    end
  end


  local function parse_string(str, i)
0   local res = ""
0   local j = i + 1
0   local k = j

0   while j <= #str do
0     local x = str:byte(j)

0     if x < 32 then
0       decode_error(str, j, "control character in string")
0     elseif x == 92 then -- `\`: Escape
0       res = res .. str:sub(k, j - 1)
0       j = j + 1
0       local c = str:sub(j, j)
0       if c == "u" then
0         local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
0             or str:match("^%x%x%x%x", j + 1)
0             or decode_error(str, j - 1, "invalid unicode escape in string")
0         res = res .. parse_unicode_escape(hex)
0         j = j + #hex
        else
0         if not escape_chars[c] then
0           decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
          end
0         res = res .. escape_char_map_inv[c]
        end
0       k = j + 1
0     elseif x == 34 then -- `"`: End of string
0       res = res .. str:sub(k, j - 1)
0       return res, j + 1
      end

0     j = j + 1
    end

0   decode_error(str, i, "expected closing quote for string")
  end


  local function parse_number(str, i)
0   local x = next_char(str, i, delim_chars)
0   local s = str:sub(i, x - 1)
0   local n = tonumber(s)
0   if not n then
0     decode_error(str, i, "invalid number '" .. s .. "'")
    end
0   return n, x
  end


  local function parse_literal(str, i)
0   local x = next_char(str, i, delim_chars)
0   local word = str:sub(i, x - 1)
0   if not literals[word] then
0     decode_error(str, i, "invalid literal '" .. word .. "'")
    end
0   return literal_map[word], x
  end


  local function parse_array(str, i)
0   local res = {}
0   local n = 1
0   i = i + 1
0   while 1 do
      local x
0     i = next_char(str, i, space_chars, true)
      -- Empty / end of array?
0     if str:sub(i, i) == "]" then
0       i = i + 1
        break
      end
      -- Read token
0     x, i = parse(str, i)
0     res[n] = x
0     n = n + 1
      -- Next token
0     i = next_char(str, i, space_chars, true)
0     local chr = str:sub(i, i)
0     i = i + 1
0     if chr == "]" then break end
0     if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
    end
0   return res, i
  end


  local function parse_object(str, i)
0   local res = {}
0   i = i + 1
0   while 1 do
      local key, val
0     i = next_char(str, i, space_chars, true)
      -- Empty / end of object?
0     if str:sub(i, i) == "}" then
0       i = i + 1
        break
      end
      -- Read key
0     if str:sub(i, i) ~= '"' then
0       decode_error(str, i, "expected string for key")
      end
0     key, i = parse(str, i)
      -- Read ':' delimiter
0     i = next_char(str, i, space_chars, true)
0     if str:sub(i, i) ~= ":" then
0       decode_error(str, i, "expected ':' after key")
      end
0     i = next_char(str, i + 1, space_chars, true)
      -- Read value
0     val, i = parse(str, i)
      -- Set
0     res[key] = val
      -- Next token
0     i = next_char(str, i, space_chars, true)
0     local chr = str:sub(i, i)
0     i = i + 1
0     if chr == "}" then break end
0     if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
    end
0   return res, i
  end


* local char_func_map = {
*   ['"'] = parse_string,
*   ["0"] = parse_number,
*   ["1"] = parse_number,
*   ["2"] = parse_number,
*   ["3"] = parse_number,
*   ["4"] = parse_number,
*   ["5"] = parse_number,
*   ["6"] = parse_number,
*   ["7"] = parse_number,
*   ["8"] = parse_number,
*   ["9"] = parse_number,
*   ["-"] = parse_number,
*   ["t"] = parse_literal,
*   ["f"] = parse_literal,
*   ["n"] = parse_literal,
*   ["["] = parse_array,
*   ["{"] = parse_object,
  }


  parse = function(str, idx)
0   local chr = str:sub(idx, idx)
0   local f = char_func_map[chr]
0   if f then
0     return f(str, idx)
    end
0   decode_error(str, idx, "unexpected character '" .. chr .. "'")
  end


* function json.decode(str)
0   if type(str) ~= "string" then
0     error("expected argument of type string, got " .. type(str))
    end
0   local res, idx = parse(str, next_char(str, 1, space_chars, true))
0   idx = next_char(str, idx, space_chars, true)
0   if idx <= #str then
0     decode_error(str, idx, "trailing garbage")
    end
0   return res
  end

* return json

==============================================================================
test/mocked-env/ao/handlers.lua
==============================================================================
* local handlers = { _version = "0.0.3" }

* handlers.utils = require "handlers-utils"
* handlers.list = {}

  local function findIndexByProp(array, prop, value)
0   for index, object in ipairs(array) do
0     if object[prop] == value then
0       return index
      end
    end
0   return nil
  end

* function handlers.add(name, pattern, handle)
0   assert(type(name) == 'string' and type(pattern) == 'function' and type(handle) == 'function',
0     'invalid arguments: handler.add(name : string, pattern : function(msg: Message) : {-1 = break, 0 = skip, 1 = continue}, handle(msg : Message) : void)')
0   assert(type(name) == 'string', 'name MUST be string')
0   assert(type(pattern) == 'function', 'pattern MUST be function')
0   assert(type(handle) == 'function', 'handle MUST be function')


    -- update existing handler by name
0   local idx = findIndexByProp(handlers.list, "name", name)
0   if idx ~= nil and idx > 0 then
      -- found update
0     handlers.list[idx].pattern = pattern
0     handlers.list[idx].handle = handle
    else
      -- not found then add
0     table.insert(handlers.list, { pattern = pattern, handle = handle, name = name })
    end
  end

* function handlers.append(name, pattern, handle)
0   assert(type(name) == 'string' and type(pattern) == 'function' and type(handle) == 'function',
0     'invalid arguments: handler.append(name : string, pattern : function(msg: Message) : {-1 = break, 0 = skip, 1 = continue}, handle(msg : Message) : void)')
0   assert(type(name) == 'string', 'name MUST be string')
0   assert(type(pattern) == 'function', 'pattern MUST be function')
0   assert(type(handle) == 'function', 'handle MUST be function')

    -- update existing handler by name
0   local idx = findIndexByProp(handlers.list, "name", name)
0   if idx ~= nil and idx > 0 then
      -- found update
0     handlers.list[idx].pattern = pattern
0     handlers.list[idx].handle = handle
    else
0     table.insert(handlers.list, { pattern = pattern, handle = handle, name = name })
    end
  end

* function handlers.prepend(name, pattern, handle)
0   assert(type(name) == 'string' and type(pattern) == 'function' and type(handle) == 'function',
0     'invalid arguments: handler.prepend(name : string, pattern : function(msg: Message) : {-1 = break, 0 = skip, 1 = continue}, handle(msg : Message) : void)')
0   assert(type(name) == 'string', 'name MUST be string')
0   assert(type(pattern) == 'function', 'pattern MUST be function')
0   assert(type(handle) == 'function', 'handle MUST be function')


    -- update existing handler by name
0   local idx = findIndexByProp(handlers.list, "name", name)
0   if idx ~= nil and idx > 0 then
      -- found update
0     handlers.list[idx].pattern = pattern
0     handlers.list[idx].handle = handle
    else
0     table.insert(handlers.list, 1, { pattern = pattern, handle = handle, name = name })
    end
  end

* function handlers.before(handleName)
0   assert(handleName ~= nil,
0     'invalid arguments: handlers.before(name : string) : { add = function(name, pattern, handler)}')
0   assert(type(handleName) == 'string', 'name MUST be string')

0   local idx = findIndexByProp(handlers.list, "name", handleName)
0   return {
      add = function(name, pattern, handle)
0       assert(type(name) == 'string' and type(pattern) == 'function' and type(handle) == 'function',
0         'invalid arguments: handler.before("foo").add(name : string, pattern : function(msg: Message) : {-1 = break, 0 = skip, 1 = continue}, handle(msg : Message) : void)')
0       assert(type(name) == 'string', 'name MUST be string')

0       assert(type(pattern) == 'function', 'pattern MUST be function')
0       assert(type(handle) == 'function', 'handle MUST be function')

0       if idx then
0         table.insert(handlers.list, idx, { pattern = pattern, handle = handle, name = name })
        end
      end
    }
  end

* function handlers.after(handleName)
0   assert(handleName ~= nil,
0     'invalid arguments: handlers.after(name : string) : { add = function(name, pattern, handler)}')
0   assert(type(handleName) == 'string', 'name MUST be string')
0   local idx = findIndexByProp(handlers.list, "name", handleName)
0   return {
      add = function(name, pattern, handle)
0       assert(type(name) == 'string' and type(pattern) == 'function' and type(handle) == 'function',
0         'invalid arguments: handler.after("foo").add(name : string, pattern : function(msg: Message) : {-1 = break, 0 = skip, 1 = continue}, handle(msg : Message) : void)')

0       assert(type(name) == 'string', 'name MUST be string')
0       assert(type(pattern) == 'function', 'pattern MUST be function')
0       assert(type(handle) == 'function', 'handle MUST be function')

0       if idx then
0         table.insert(handlers.list, idx + 1, { pattern = pattern, handle = handle, name = name })
        end
      end
    }
  end

* function handlers.remove(name)
0   assert(type(name) == 'string', 'name MUST be string')
0   if #handlers.list == 1 and handlers.list[1].name == name then
0     handlers.list = {}
    end

0   local idx = findIndexByProp(handlers.list, "name", name)
0   table.remove(handlers.list, idx)
  end

  --- return 0 to not call handler, -1 to break after handler is called, 1 to continue
* function handlers.evaluate(msg, env)
0   printVerb(2)('> LOG: ' ..
0     'Evaluating msg --- From ' ..
0     msg.From ..
0     ' To ' .. msg.Target .. tostring(msg.Tags.Action and ' - (Action = ' .. msg.Tags.Action .. ')' or ' - ()'))
0   local handled = false
0   assert(type(msg) == 'table', 'msg is not valid')
0   assert(type(env) == 'table', 'env is not valid')

0   for _, o in ipairs(handlers.list) do
0     if o.name ~= "_default" then
0       local match = o.pattern(msg)
0       if not (type(match) == 'number' or type(match) == 'string' or type(match) == 'boolean') then
0         error({ message = "pattern result is not valid, it MUST be string, number, or boolean" })
        end

        -- handle boolean returns
0       if type(match) == "boolean" and match == true then
0         match = -1
0       elseif type(match) == "boolean" and match == false then
0         match = 0
        end

        -- handle string returns
0       if type(match) == "string" then
0         if match == "continue" then
0           match = 1
0         elseif match == "break" then
0           match = -1
          else
0           match = 0
          end
        end

0       if match ~= 0 then
0         if match < 0 then
0           handled = true
          end
          -- each handle function can accept, the msg, env
0         local status, err = pcall(o.handle, msg, env)
0         if not status then
0           error(err)
0           ao.outbox.Error = { err = err }
          end
        end
0       if match < 0 then
0         return handled
        end
      end
    end
    -- do default
0   printVerb(2)('> LOG: ' .. 'SKIPPING DEFAULT HANDLER')
    -- if not handled then
    --   local idx = findIndexByProp(handlers.list, "name", "_default")
    --   handlers.list[idx].handle(msg, env)
    -- end
  end

* return handlers

==============================================================================
test/mocked-env/ao/ao.lua
==============================================================================
* local utils = require ".utils"

  local function newmodule(selfId)
*   local ao = {}
*   ao.id = selfId

*   local _my = {}

    --[[
      if message is for the process we're testing, handle according to globally defined handlers
      otherwise, use simplified mock handling with dedicated module representing the target process

      @param rawMsg table with key-value pairs representing
      {
        Target = string, -- process id
        From = string, -- process id or wallet id; if not provided, defaults to self
        Data = string, -- message data
        Tags = table, -- key-value pairs representing message tags
        TagName1 = TagValue1, -- tag key-value pair of strings
        TagName2 = TagValue2, -- tag key-value pair of strings
      }
    ]]
*   function ao.send(rawMsg)
0     if _G.IsInUnitTest then return end

0     local msg = _my.formatMsg(rawMsg)

0     if msg.Target == _G.Owner then
0       printVerb(2)('⚠️ Skip handle: Message from ' .. msg.From .. ' to agent owner: ' .. tostring(msg.Action))
        -- ALTERNATIVELY: _G.LastMessageToOwner = msg
0       return
      end

0     if msg.Target == _G.MainProcessId then
0       _G.Handlers.evaluate(msg, _my.env)
      else
0       local targetProcess = _G.Processes[msg.Target]
0       if targetProcess then
0         targetProcess.handle(msg)
        else
0         error('!!! No handler found for target process: ' .. msg.Target)
        end
      end
    end

    -- INTERNAL

*   _my.env = {
*     Process = {
*       Id = '9876',
*       Tags = {
          {
*           name = 'Data-Protocol',
*           value = 'ao'
*         },
          {
*           name = 'Variant',
*           value = 'ao.TN.1'
*         },
          {
*           name = 'Type',
*           value = 'Process'
          }
*       }
*     },
*     Module = {
*       Id = '4567',
*       Tags = {
          {
*           name = 'Data-Protocol',
*           value = 'ao'
*         },
          {
*           name = 'Variant',
*           value = 'ao.TN.1'
*         },
          {
*           name = 'Type',
*           value = 'Module'
          }
*       }
*     }
*   }

    _my.createMsg = function()
0     return {
        Id = '1234',
        Target = 'AOS',
        Owner = "fcoN_xJeisVsPXA-trzVAuIiqO3ydLQxM-L4XbrQKzY",
        From = 'OWNER',
        Data = '1984',
        Tags = {},
        ['Block-Height'] = '1',
        Timestamp = _G.VirtualTime or os.time(),
0       Module = '4567'
      }
    end

    _my.formatMsg = function(msg)
0     local formattedMsg = _my.createMsg()
      -- allow these top-level keys to be overwritten
0     formattedMsg.From = msg.From or ao.id
0     formattedMsg.Data = msg.Data or nil
0     formattedMsg.Timestamp = msg.Timestamp or formattedMsg.Timestamp

      -- handle tags
0     formattedMsg.Tags = msg.Tags or formattedMsg.Tags
0     for k, v in pairs(msg) do
0       if not formattedMsg[k] then
0         formattedMsg.Tags[k] = v
        end

0       formattedMsg[k] =
            v -- TODO check for safety here in order to be complete (no top level keys like Module, Owner, From-Process, etc. should be overwritten)
      end

0     return formattedMsg
    end

*   return ao
  end

* return newmodule

==============================================================================
test/mocked-env/ao/handlers-utils.lua
==============================================================================
* local _utils = { _version = "0.0.1" }

* local _ = require '.utils'
* local ao = require "ao"
* local json = require "json"

* function _utils.hasMatchingTag(name, value)
0   assert(type(name) == 'string' and type(value) == 'string', 'invalid arguments: (name : string, value : string)')

    return function(msg)
0     return msg.Tags[name] == value
    end
  end

* function _utils.hasMatchingTagOf(name, values)
0   assert(type(name) == 'string' and type(values) == 'table', 'invalid arguments: (name : string, values : string[])')
    return function(msg)
0     for _, value in ipairs(values) do
0       local patternResult = Handlers.utils.hasMatchingTag(name, value)(msg)

0       if patternResult ~= 0 and patternResult ~= false and patternResult ~= "skip" then
0         return patternResult
        end
      end

0     return 0
    end
  end

* function _utils.hasMatchingData(value)
0   assert(type(value) == 'string', 'invalid arguments: (value : string)')
    return function(msg)
0     return msg.Data == value
    end
  end

* function _utils.reply(input)
0   assert(type(input) == 'table' or type(input) == 'string', 'invalid arguments: (input : table or string)')
    return function(msg)
0     if type(input) == 'string' then
0       ao.send({ Target = msg.From, Data = input })
0       return
      end
0     ao.send({ Target = msg.From, Tags = input })
    end
  end

* function _utils.continue(fn)
0   assert(type(fn) == 'function', 'invalid arguments: (fn : function)')
    return function(msg)
0     local patternResult = fn(msg)

0     if not patternResult or patternResult == 0 or patternResult == "skip" then
0       return patternResult
      end
0     return 1
    end
  end

* return _utils

==============================================================================
Summary
==============================================================================

File                                   Hits Missed Coverage
-----------------------------------------------------------
tlconfig.lua                           0    2      0.00%
build/tokenManager.lua                 0    6      0.00%
test/mocked-env/processes/aocred.lua   0    9      0.00%
build/globals.lua                      0    11     0.00%
scripts/copy_lua_package.lua           0    24     0.00%
build/dbUtils.lua                      0    37     0.00%
build/database.lua                     0    40     0.00%
build/providerManager.lua              0    172    0.00%
build/main.lua                         0    232    0.00%
build/verifierManager.lua              0    253    0.00%
build/randomManager.lua                0    277    0.00%
test/mocked-env/lib/bint.lua           0    833    0.00%
process.lua                            0    1042   0.00%
test/mocked-env/ao/handlers.lua        11   95     10.38%
test/process_test.lua                  39   258    13.13%
test/mocked-env/lib/utils.lua          23   74     23.71%
test/mocked-env/lib/json.lua           51   148    25.63%
test/mocked-env/ao/handlers-utils.lua  10   20     33.33%
test/mocked-env/processes/verifier.lua 7    6      53.85%
test/mocked-env/ao/ao.lua              35   23     60.34%
test/setup.lua                         15   4      78.95%
-----------------------------------------------------------
Total                                  191  3566   5.08%
